---
import Layout from '../layouts/Layout.astro';
import { benchmarks } from '../data/benchmarks';
import { getSimulatedDate, TIME_OFFSET } from '../scripts/TimeUtils';
import en from '../locales/en.json';
import ptBR from '../locales/pt-BR.json';
import ja from '../locales/ja.json';
import es from '../locales/es.json';
import zh from '../locales/zh.json';

const translations = {
    'en': en,
    'pt-BR': ptBR,
    'ja': ja,
    'es': es,
    'zh': zh,
};

const lang = 'en';
const t = translations[lang];

// --- Simulated Time for Context ---
const SIMULATED_NOW = getSimulatedDate();

function isNew(dateStr) {
    if (!dateStr) return false;
    const release = new Date(dateStr);
    const now = new Date(SIMULATED_NOW);
    // Reset hours to compare just dates
    release.setHours(0,0,0,0);
    now.setHours(0,0,0,0);

    const diffTime = now.getTime() - release.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    // Show new for items released in the last 30 days
    return diffDays >= -1 && diffDays <= 30;
}

// --- Ranking Logic ---
function computeRanks(items, scoreKey) {
    // 1. Sort
    let sorted = [...items].sort((a, b) => {
        // Human Baseline always on top if it exists, though score usually handles it
        if (a.name === 'Human Baseline') return -1;
        if (b.name === 'Human Baseline') return 1;
        return b[scoreKey] - a[scoreKey];
    });

    // 2. Separate Zeroes
    const eligible = sorted.filter(i => i[scoreKey] > 0);
    const fails = sorted.filter(i => i[scoreKey] === 0).sort((a,b) => a.name.localeCompare(b.name));

    // 3. Assign ranks to eligible
    let currentRank = 1;
    let previousScore = null;
    let rankedItems = [];

    eligible.forEach((item) => {
        if (item.name === 'Human Baseline') {
            rankedItems.push({ ...item, rank: '-', isFail: false });
            return;
        }

        const score = item[scoreKey];

        if (previousScore !== null && score < previousScore) {
            currentRank++;
        }

        rankedItems.push({ ...item, rank: currentRank, isFail: false });
        previousScore = score;
    });

    // 4. Append Fails
    fails.forEach(item => {
        rankedItems.push({ ...item, rank: 'EPIC FAIL', isFail: true });
    });

    return rankedItems;
}

// Easy Mode Logic (Averages)
const rawEasy = benchmarks.models.map(m => {
    const scores = Object.values(m.scores);
    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    return { ...m, avg };
});
const easyList = computeRanks(rawEasy, 'avg');

// Hard Mode Logic
const hardList = computeRanks(benchmarks.hardMode, 'score');

// Impossible Mode Logic
const impossibleList = computeRanks(benchmarks.impossibleMode, 'score');

const maxRows = Math.max(easyList.length, hardList.length, impossibleList.length);
const rows = Array.from({ length: maxRows }, (_, i) => i);

function getRankDisplay(rank) {
    if (rank === '-') return '-';
    if (rank === 'EPIC FAIL') return 'EPIC FAIL';
    if (rank === 1) return 'ðŸ¥‡';
    if (rank === 2) return 'ðŸ¥ˆ';
    if (rank === 3) return 'ðŸ¥‰';
    return `#${rank}`;
}
---

<Layout lang={lang} title={`${t.leaderboard_button} - ${t.title}`}>
    <main>
        <h1 id="leaderboard-title">{t.leaderboard_button}</h1>

        <div class="leaderboard-grid">
            <!-- Benchmarks Section -->
            <section class="leaderboard-section full-width">
                <h2 id="benchmark-title">{t.benchmark_title}</h2>

                <div class="benchmark-scroll-container">
                    <div class="benchmark-container">
                        <!-- Header Row -->
                        <div class="header-row">
                            <div class="col-header"><h3>EASY MODE</h3></div>
                            <div class="col-header"><h3>HARD MODE</h3></div>
                            <div class="col-header impossible-header"><h3>IMPOSSIBLE MODE</h3></div>
                        </div>

                        <!-- Rows Loop -->
                        {rows.map(i => {
                            const easyItem = easyList[i];
                            const hardItem = hardList[i];
                            const impossibleItem = impossibleList[i];

                            return (
                                <div class="benchmark-row">
                                    {/* Easy Column */}
                                    <div class="benchmark-cell easy-col">
                                        {easyItem && (
                                            <div class={`benchmark-content ${easyItem.isFail ? 'fail-item' : ''} ${easyItem.name === 'Human Baseline' ? 'human-baseline' : ''}`}>
                                                <div class={`rank ${easyItem.isFail ? 'fail-rank' : ''}`}>
                                                    {getRankDisplay(easyItem.rank)}
                                                </div>
                                                <div class="model-info">
                                                    <div class="model-name" data-release-date={easyItem.releaseDate}>
                                                        {easyItem.name}
                                                        {isNew(easyItem.releaseDate) && <span class="new-badge">NEW</span>}
                                                    </div>
                                                </div>
                                                <div class={`model-score ${easyItem.isFail ? 'fail-score' : ''}`}>{easyItem.avg.toFixed(1)}%</div>
                                            </div>
                                        )}
                                    </div>

                                    {/* Hard Column */}
                                    <div class="benchmark-cell hard-col">
                                        {hardItem && (
                                            <div class={`benchmark-content ${hardItem.isFail ? 'fail-item' : ''} ${hardItem.name === 'Human Baseline' ? 'human-baseline' : ''}`}>
                                                <div class={`rank ${hardItem.isFail ? 'fail-rank' : ''}`}>
                                                    {getRankDisplay(hardItem.rank)}
                                                </div>
                                                <div class="model-info">
                                                    <div class="model-name" data-release-date={hardItem.releaseDate}>
                                                        {hardItem.name}
                                                        {isNew(hardItem.releaseDate) && <span class="new-badge">NEW</span>}
                                                    </div>
                                                </div>
                                                <div class={`model-score ${hardItem.isFail ? 'fail-score' : ''}`}>{hardItem.score}%</div>
                                            </div>
                                        )}
                                    </div>

                                    {/* Impossible Column */}
                                    <div class="benchmark-cell impossible-col">
                                        {impossibleItem && (
                                            <div class={`benchmark-content ${impossibleItem.isFail ? 'fail-item' : ''} ${impossibleItem.name === 'Human Baseline' ? 'human-baseline' : ''}`}>
                                                <div class={`rank ${impossibleItem.isFail ? 'fail-rank' : ''} ${impossibleItem.isFail ? '' : 'impossible-rank'}`}>
                                                    {getRankDisplay(impossibleItem.rank)}
                                                </div>
                                                <div class="model-info">
                                                    <div class={`model-name ${impossibleItem.isFail ? '' : 'impossible-text'}`} data-release-date={impossibleItem.releaseDate}>
                                                        {impossibleItem.name}
                                                        {isNew(impossibleItem.releaseDate) && <span class="new-badge">NEW</span>}
                                                    </div>
                                                </div>
                                                <div class={`model-score ${impossibleItem.isFail ? 'fail-score' : 'impossible-score'}`}>{impossibleItem.score}%</div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            );
                        })}

                        <p class="disclaimer" id="benchmark-disclaimer">{t.benchmark_impossible_disclaimer}</p>
                        <p class="disclaimer contact-disclaimer" id="benchmark-contact">{t.benchmark_contact_disclaimer}</p>
                    </div>
                </div>
            </section>
        </div>
    </main>
</Layout>

<style>
    main {
        max-width: 90rem; /* Wide layout */
        margin: 4rem auto;
        padding: 0 1rem;
    }

    h1 {
        font-size: 3rem;
        font-weight: 900;
        text-align: center;
        margin-bottom: 3rem;
        color: white;
        background: linear-gradient(to right, #F59E0B, #EF4444);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    h2 {
        font-size: 2rem;
        font-weight: 700;
        color: white;
        margin-bottom: 1.5rem;
        text-align: center;
    }

    /* Scroll Container for Mobile */
    .benchmark-scroll-container {
        overflow-x: auto;
        padding-bottom: 1rem;
    }

    .benchmark-container {
        background: rgba(31, 41, 55, 0.5);
        border-radius: 1rem;
        padding: 2rem;
        box-shadow: 0 0 30px rgba(0,0,0,0.2);
        border: 1px solid rgba(245, 158, 11, 0.3);
        min-width: 900px; /* Force minimum width to keep columns legible */
    }

    /* Header Row */
    .header-row {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        /* No border bottom here, headers have their own style */
    }

    .col-header h3 {
        font-size: 1.5rem;
        font-weight: 800;
        color: #F59E0B;
        margin-bottom: 1rem;
        border-bottom: 2px solid rgba(245, 158, 11, 0.3);
        padding-bottom: 0.5rem;
        text-align: center;
    }

    /* Benchmark Rows */
    .benchmark-row {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Horizontal line */
    }

    .benchmark-row:last-child {
        border-bottom: none;
    }

    /* Cells */
    .benchmark-cell {
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
    }

    /* Vertical Lines */
    .easy-col {
        border-right: 1px solid rgba(255, 255, 255, 0.1);
    }
    .hard-col {
        border-right: 1px solid rgba(255, 255, 255, 0.1);
    }
    /* Impossible col needs no right border */

    /* Content Layout inside Cell */
    .benchmark-content {
        display: flex;
        width: 100%;
        align-items: center;
        gap: 0.75rem;
    }

    .rank {
        font-size: 1.1rem;
        font-weight: 900;
        color: #F59E0B;
        min-width: 25px;
        text-align: center;
    }

    .human-baseline { opacity: 0.8; }
    .human-baseline .rank { color: #9CA3AF; }
    .fail-rank { color: #EF4444; font-size: 0.9rem; min-width: 70px; text-align: left; }

    .model-info {
        flex: 1;
        min-width: 0; /* Text truncate */
    }

    .model-name {
        font-size: 0.95rem;
        font-weight: 600; /* Slightly lighter than card title */
        color: white;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .model-score {
        font-size: 1.1rem;
        font-weight: 900;
        color: #F59E0B;
        margin-left: auto;
    }

    .fail-score { color: #6B7280; font-size: 0.9rem; }

    /* Impossible Mode Styles */
    .impossible-header h3 {
        color: #ef4444;
        text-shadow:
            0 0 4px #7f1d1d,
            0 -5px 4px #ff9c00,
            2px -10px 6px #fd3e3e,
            -2px -15px 11px #f00;
        animation: burn 1.5s ease-in-out infinite alternate;
        border-color: #ef4444;
    }

    @keyframes burn {
        from { text-shadow: 0 0 4px #7f1d1d, 0 -5px 4px #ff9c00, 2px -10px 6px #fd3e3e, -2px -15px 11px #f00; }
        to { text-shadow: 0 0 4px #7f1d1d, 0 -2px 4px #ff9c00, 2px -5px 6px #fd3e3e, -2px -10px 11px #f00; }
    }

    .impossible-rank { color: #ef4444; }
    .impossible-score { color: #ef4444; text-shadow: 0 0 5px #7f1d1d; }
    .impossible-text { color: #fee2e2; }

    /* Override for Fail in Impossible Mode */
    .fail-item .impossible-score { color: #6B7280; text-shadow: none; }
    .fail-item .impossible-text { color: white; }

    /* New Badge */
    .new-badge {
        display: inline-block;
        margin-left: 0.3rem;
        font-size: 0.6rem;
        font-weight: 800;
        color: #713f12;
        background: linear-gradient(135deg, #fcd34d 0%, #f59e0b 100%);
        padding: 0 0.3rem;
        border-radius: 0.2rem;
        text-transform: uppercase;
        box-shadow: 0 0 5px rgba(245, 158, 11, 0.5);
        animation: shine 2s infinite;
        vertical-align: middle;
        border: 1px solid #fbbf24;
    }

    @keyframes shine {
        0% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.05); }
        100% { opacity: 1; transform: scale(1); }
    }

    .disclaimer {
        margin-top: 2rem;
        font-size: 0.9rem;
        color: #9CA3AF;
        font-style: italic;
        text-align: center;
        opacity: 0.8;
    }

    .contact-disclaimer { margin-top: 1rem; color: #60A5FA; }
</style>

<script define:vars={{ translations, lang, TIME_OFFSET }}>
    function init() {
        // --- Translations ---
        let currentLang = lang;
        try {
            currentLang = localStorage.getItem('language') || document.cookie.split('; ').find(row => row.startsWith('language='))?.split('=')[1] || lang;
        } catch (e) {
            console.warn('Language detection failed:', e);
        }

        const t = translations[currentLang] || translations['en'];

        const mainTitle = document.getElementById('leaderboard-title');
        const benchTitle = document.getElementById('benchmark-title');
        const disclaimer = document.getElementById('benchmark-disclaimer');
        const contact = document.getElementById('benchmark-contact');

        if (mainTitle) mainTitle.textContent = t.leaderboard_button;
        if (benchTitle) benchTitle.textContent = t.benchmark_title;
        if (disclaimer) disclaimer.textContent = t.benchmark_impossible_disclaimer;
        if (contact) contact.textContent = t.benchmark_contact_disclaimer;

        // --- Dynamic "NEW" Badge Logic ---
        const timeOffset = TIME_OFFSET;
        const simNow = new Date(new Date().getTime() + timeOffset);

        document.querySelectorAll('.model-name[data-release-date]').forEach(el => {
            const dateStr = el.getAttribute('data-release-date');
            if (!dateStr) return;

            const release = new Date(dateStr);
            // Reset hours
            release.setHours(0,0,0,0);
            const today = new Date(simNow);
            today.setHours(0,0,0,0);

            const diffTime = today.getTime() - release.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            // Should be new if within 30 days
            const isNew = diffDays >= -1 && diffDays <= 30;

            let badge = el.querySelector('.new-badge');
            if (isNew) {
                if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'new-badge';
                    badge.textContent = 'NEW';
                    el.appendChild(badge);
                }
            } else {
                if (badge) badge.remove();
            }
        });

        adjustFontSizes();
        window.addEventListener('resize', adjustFontSizes);
    }

    function adjustFontSizes() {
        const models = document.querySelectorAll('.model-name');
        models.forEach(el => {
            // Reset to original size to allow growth on resize
            el.style.fontSize = '0.95rem';

            let size = 0.95;
            const minSize = 0.75;

            // Reduce size while content overflows
            while (el.scrollWidth > el.clientWidth && size > minSize) {
                size -= 0.05;
                el.style.fontSize = `${size}rem`;
            }
        });
    }

    document.addEventListener('DOMContentLoaded', init);
</script>
