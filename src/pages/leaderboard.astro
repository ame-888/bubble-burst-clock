---
import Layout from '../layouts/Layout.astro';
import { benchmarks } from '../data/benchmarks';
import { predictions } from '../data/predictions';
import { getSimulatedDate, TIME_OFFSET } from '../scripts/TimeUtils';
import en from '../locales/en.json';
import ptBR from '../locales/pt-BR.json';
import ja from '../locales/ja.json';
import es from '../locales/es.json';
import zh from '../locales/zh.json';

const translations = {
    'en': en,
    'pt-BR': ptBR,
    'ja': ja,
    'es': es,
    'zh': zh,
};

const lang = 'en';
const t = translations[lang];

// --- Simulated Time for Context ---
const SIMULATED_NOW = getSimulatedDate();

function isNew(dateStr) {
    if (!dateStr) return false;
    const release = new Date(dateStr);
    const now = new Date(SIMULATED_NOW);
    // Reset hours to compare just dates
    release.setHours(0,0,0,0);
    now.setHours(0,0,0,0);

    const diffTime = now.getTime() - release.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    // Show new for items released in the last 30 days
    return diffDays >= -1 && diffDays <= 30;
}

// --- Statistical Significance Logic ---

function zTest(score1, score2) {
    // Scores can be floats (averages) or ints.
    // If scores are identical, it's a tie.
    if (score1 === score2) return true;

    const n = 100; // Sample size
    // Proportions
    const p1 = score1 / 100;
    const p2 = score2 / 100;

    // Pooled sample proportion
    const pPool = (score1 + score2) / 200;

    // Standard Error
    const se = Math.sqrt(pPool * (1 - pPool) * (2 / n));

    // If SE is 0 (both 0% or both 100%), it's a tie.
    if (se === 0) return true;

    const z = (p1 - p2) / se;

    // 95% Confidence Level (Two-tailed) -> critical value ~1.96
    return Math.abs(z) < 1.96;
}

function calculateSignificantRank(items, scoreKey) {
    // 1. Sort by score descending
    const sorted = [...items].sort((a, b) => b[scoreKey] - a[scoreKey]);

    let currentRank = 1;
    let groupLeader = sorted[0];

    return sorted.map((item, index) => {
        if (index === 0) {
            return { ...item, rank: 1, isTied: false };
        }

        // Compare current item with the leader of the current rank group
        const isTied = zTest(groupLeader[scoreKey], item[scoreKey]);

        if (isTied) {
            // Statistically tied with the group leader -> same rank
            return { ...item, rank: currentRank, isTied: true };
        } else {
            // Significant difference -> new rank
            // Rank is based on position (Competition Ranking), so index + 1
            currentRank = index + 1;
            groupLeader = item; // New leader
            return { ...item, rank: currentRank, isTied: false };
        }
    });
}

// Easy Mode Logic (Averages)
const rawEasy = benchmarks.models.map(m => {
    const scores = Object.values(m.scores);
    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    return { ...m, avg };
});
const easyModeBenchmarks = calculateSignificantRank(rawEasy, 'avg');

// Hard Mode Logic
const hardModeBenchmarks = calculateSignificantRank(benchmarks.hardMode, 'score');

// Impossible Mode Logic
// User requested strict sorting and ranking for this mode too ("Absolutamente sim")
const impossibleModeBenchmarks = calculateSignificantRank(benchmarks.impossibleMode, 'score');

// Serial Popper Logic (Standard Ranking)
const creatorCounts: Record<string, number> = {};
predictions.forEach(p => {
    creatorCounts[p.creator] = (creatorCounts[p.creator] || 0) + 1;
});

const serialPoppers = Object.entries(creatorCounts)
    .filter(([name, count]) => count > 1)
    .map(([name, count]) => ({ name, count }))
    .sort((a, b) => b.count - a.count);

function getRankEmoji(rank) {
    if (rank === 1) return 'ü•á';
    if (rank === 2) return 'ü•à';
    if (rank === 3) return 'ü•â';
    return `#${rank}`;
}
---

<Layout lang={lang} title={`${t.leaderboard_button} - ${t.title}`}>
    <main>
        <h1 id="leaderboard-title">{t.leaderboard_button}</h1>

        <div class="leaderboard-grid">
            <!-- Benchmarks Section -->
            <section class="leaderboard-section">
                <h2 id="benchmark-title">{t.benchmark_title}</h2>

                <div class="benchmark-container">
                    <!-- Easy Mode -->
                     <div class="mode-header">
                        <h3>EASY MODE</h3>
                    </div>
                    <div class="benchmark-list">
                        {easyModeBenchmarks.map((m) => (
                            <div class="benchmark-item">
                                <div class="rank">
                                    {getRankEmoji(m.rank)}
                                    {m.isTied && <span class="tie-symbol">‚âà</span>}
                                </div>
                                <div class="model-info">
                                    <div class="model-name" data-release-date={m.releaseDate}>
                                        {m.name}
                                        {isNew(m.releaseDate) && <span class="new-badge">NEW</span>}
                                    </div>
                                </div>
                                <div class="model-score">{m.avg.toFixed(1)}%</div>
                            </div>
                        ))}
                    </div>

                    <div class="spacer"></div>

                    <!-- Hard Mode -->
                    <div class="mode-header">
                        <h3>HARD MODE</h3>
                    </div>
                    <div class="benchmark-list">
                        {hardModeBenchmarks.map((m) => (
                            <div class="benchmark-item">
                                <div class="rank">
                                    {getRankEmoji(m.rank)}
                                    {m.isTied && <span class="tie-symbol">‚âà</span>}
                                </div>
                                <div class="model-info">
                                    <div class="model-name" data-release-date={m.releaseDate}>
                                        {m.name}
                                        {isNew(m.releaseDate) && <span class="new-badge">NEW</span>}
                                    </div>
                                </div>
                                <div class="model-score">{m.score}%</div>
                            </div>
                        ))}
                    </div>

                    <div class="spacer"></div>

                    <!-- Impossible Mode -->
                    <div class="mode-header impossible-header">
                        <h3>IMPOSSIBLE MODE</h3>
                    </div>
                    <div class="benchmark-list">
                        {impossibleModeBenchmarks.map((m) => (
                            <div class="benchmark-item">
                                <div class="rank impossible-rank">
                                    {getRankEmoji(m.rank)}
                                    {m.isTied && <span class="tie-symbol">‚âà</span>}
                                </div>
                                <div class="model-info">
                                    <div class="model-name impossible-text" data-release-date={m.releaseDate}>
                                        {m.name}
                                        {isNew(m.releaseDate) && <span class="new-badge">NEW</span>}
                                    </div>
                                </div>
                                <div class="model-score impossible-score">{m.score}%</div>
                            </div>
                        ))}
                    </div>
                    <p class="disclaimer" id="benchmark-disclaimer">{t.benchmark_impossible_disclaimer}</p>
                </div>
            </section>

            <!-- Serial Poppers Section -->
            <section class="leaderboard-section">
                <h2 id="serial-popper-title">{t.serial_popper_modal_title}</h2>
                <div class="serial-popper-container">
                    <div class="serial-popper-list">
                        {serialPoppers.length > 0 ? (
                            serialPoppers.map((sp, index) => (
                                <div class="serial-popper-item">
                                    <div class="rank">{getRankEmoji(index + 1)}</div>
                                    <div class="popper-info">
                                        <div class="popper-name">{sp.name} üçø</div>
                                        <div class="popper-count"><span id="serial-popper-count-label">{t.serial_popper_count_label}</span>: {sp.count}</div>
                                    </div>
                                </div>
                            ))
                        ) : (
                            <p class="no-data">No serial poppers yet...</p>
                        )}
                    </div>
                </div>
            </section>
        </div>
    </main>
</Layout>

<style>
    main {
        max-width: 80rem;
        margin: 4rem auto;
        padding: 0 1rem;
    }

    h1 {
        font-size: 3rem;
        font-weight: 900;
        text-align: center;
        margin-bottom: 3rem;
        color: white;
        background: linear-gradient(to right, #F59E0B, #EF4444);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    h2 {
        font-size: 2rem;
        font-weight: 700;
        color: white;
        margin-bottom: 1.5rem;
        text-align: center;
    }

    .mode-header h3 {
        font-size: 1.5rem;
        font-weight: 800;
        color: #F59E0B;
        margin-bottom: 1rem;
        border-bottom: 2px solid rgba(245, 158, 11, 0.3);
        padding-bottom: 0.5rem;
    }

    .spacer {
        height: 3rem;
    }

    .leaderboard-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 4rem;
    }

    @media (min-width: 900px) {
        .leaderboard-grid {
            grid-template-columns: 1fr 1fr;
            align-items: start;
        }
    }

    .benchmark-container, .serial-popper-container {
        background: rgba(31, 41, 55, 0.5);
        border-radius: 1rem;
        padding: 2rem;
        box-shadow: 0 0 30px rgba(0,0,0,0.2);
    }

    .benchmark-container {
        border: 1px solid rgba(245, 158, 11, 0.3);
    }

    .serial-popper-container {
        border: 1px solid rgba(248, 113, 113, 0.3);
    }

    .benchmark-list, .serial-popper-list {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .benchmark-item, .serial-popper-item {
        display: flex;
        gap: 1rem;
        align-items: center;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .benchmark-item:last-child, .serial-popper-item:last-child { border-bottom: none; padding-bottom: 0; }

    .rank {
        font-size: 1.5rem;
        font-weight: 900;
        color: #F59E0B;
        min-width: 40px;
        text-align: center;
        /* Allow tie symbol to sit next to emoji */
        white-space: nowrap;
    }

    .tie-symbol {
        font-size: 1rem;
        margin-left: 0.2rem;
        vertical-align: super;
        opacity: 0.8;
    }

    .serial-popper-item .rank {
        color: #EF4444;
    }

    .model-info, .popper-info {
        flex: 1;
    }

    .model-name, .popper-name {
        font-size: 1.1rem;
        font-weight: 700;
        color: white;
    }

    .model-score {
        font-size: 1.5rem;
        font-weight: 900;
        color: #F59E0B;
    }

    .popper-count {
        font-size: 0.9rem;
        color: #9CA3AF;
        margin-bottom: 0.5rem;
    }

    .no-data {
        text-align: center;
        color: #9CA3AF;
        font-style: italic;
    }

    /* Impossible Mode Styles */
    .impossible-header h3 {
        color: #ef4444;
        text-shadow:
            0 0 4px #7f1d1d,
            0 -5px 4px #ff9c00,
            2px -10px 6px #fd3e3e,
            -2px -15px 11px #f00;
        animation: burn 1.5s ease-in-out infinite alternate;
        border-color: #ef4444;
    }

    @keyframes burn {
        from { text-shadow: 0 0 4px #7f1d1d, 0 -5px 4px #ff9c00, 2px -10px 6px #fd3e3e, -2px -15px 11px #f00; }
        to { text-shadow: 0 0 4px #7f1d1d, 0 -2px 4px #ff9c00, 2px -5px 6px #fd3e3e, -2px -10px 11px #f00; }
    }

    .impossible-rank {
        color: #ef4444;
    }

    .impossible-score {
        color: #ef4444;
        text-shadow: 0 0 5px #7f1d1d;
    }

    .impossible-text {
        color: #fee2e2; /* Light red/white for contrast */
    }

    /* New Badge Styles */
    .new-badge {
        display: inline-block;
        margin-left: 0.5rem;
        font-size: 0.7rem;
        font-weight: 800;
        color: #713f12; /* Dark gold text */
        background: linear-gradient(135deg, #fcd34d 0%, #f59e0b 100%);
        padding: 0.1rem 0.4rem;
        border-radius: 0.25rem;
        text-transform: uppercase;
        box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        animation: shine 2s infinite;
        vertical-align: middle;
        border: 1px solid #fbbf24;
    }

    @keyframes shine {
        0% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.05); }
        100% { opacity: 1; transform: scale(1); }
    }

    .disclaimer {
        margin-top: 2rem;
        font-size: 0.9rem;
        color: #9CA3AF;
        font-style: italic;
        text-align: center;
        opacity: 0.8;
    }
</style>

<script define:vars={{ translations, lang, TIME_OFFSET }}>
    function init() {
        // --- Translations ---
        let currentLang = lang;
        try {
            currentLang = localStorage.getItem('language') || document.cookie.split('; ').find(row => row.startsWith('language='))?.split('=')[1] || lang;
        } catch (e) {
            console.warn('Language detection failed:', e);
        }

        const t = translations[currentLang] || translations['en'];

        const mainTitle = document.getElementById('leaderboard-title');
        const benchTitle = document.getElementById('benchmark-title');
        const popperTitle = document.getElementById('serial-popper-title');
        const popperLabel = document.getElementById('serial-popper-count-label');
        const disclaimer = document.getElementById('benchmark-disclaimer');

        if (mainTitle) mainTitle.textContent = t.leaderboard_button;
        if (benchTitle) benchTitle.textContent = t.benchmark_title;
        if (popperTitle) popperTitle.textContent = t.serial_popper_modal_title;
        if (popperLabel) popperLabel.textContent = t.serial_popper_count_label;
        if (disclaimer) disclaimer.textContent = t.benchmark_impossible_disclaimer;

        // --- Dynamic "NEW" Badge Logic ---
        const timeOffset = TIME_OFFSET;
        const simNow = new Date(new Date().getTime() + timeOffset);

        document.querySelectorAll('.model-name[data-release-date]').forEach(el => {
            const dateStr = el.getAttribute('data-release-date');
            if (!dateStr) return;

            const release = new Date(dateStr);
            // Reset hours
            release.setHours(0,0,0,0);
            const today = new Date(simNow);
            today.setHours(0,0,0,0);

            const diffTime = today.getTime() - release.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            // Should be new if within 30 days
            const isNew = diffDays >= -1 && diffDays <= 30;

            let badge = el.querySelector('.new-badge');
            if (isNew) {
                if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'new-badge';
                    badge.textContent = 'NEW';
                    el.appendChild(badge);
                }
            } else {
                if (badge) badge.remove();
            }
        });
    }

    document.addEventListener('DOMContentLoaded', init);
</script>
