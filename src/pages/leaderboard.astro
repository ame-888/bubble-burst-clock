---
import Layout from '../layouts/Layout.astro';
import { benchmarks } from '../data/benchmarks';
import { getSimulatedDate, TIME_OFFSET } from '../scripts/TimeUtils';
import en from '../locales/en.json';
import ptBR from '../locales/pt-BR.json';
import ja from '../locales/ja.json';
import es from '../locales/es.json';
import zh from '../locales/zh.json';

const translations = {
    'en': en,
    'pt-BR': ptBR,
    'ja': ja,
    'es': es,
    'zh': zh,
};

const lang = 'en';
const t = translations[lang];

// --- Simulated Time for Context ---
const SIMULATED_NOW = getSimulatedDate();

function isNew(dateStr) {
    if (!dateStr) return false;
    const release = new Date(dateStr);
    const now = new Date(SIMULATED_NOW);
    // Reset hours to compare just dates
    release.setHours(0,0,0,0);
    now.setHours(0,0,0,0);

    const diffTime = now.getTime() - release.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    // Show new for items released in the last 30 days
    return diffDays >= -1 && diffDays <= 30;
}

// --- New Ranking Logic ---
function calculateRank(items, scoreKey) {
    // 1. Sort by score descending
    let sorted = [...items].sort((a, b) => b[scoreKey] - a[scoreKey]);

    // 2. Separate 0 scores and move to bottom, sorted alphabetically
    const nonZero = sorted.filter(item => item[scoreKey] > 0);
    const zeroScores = sorted.filter(item => item[scoreKey] === 0);

    zeroScores.sort((a, b) => a.name.localeCompare(b.name));

    sorted = [...nonZero, ...zeroScores];

    let currentRank = 1;

    return sorted.map((item, index) => {
        // Human Baseline Logic
        if (item.name === 'Human Baseline') {
            return { ...item, rank: '-', isFail: false, displayScore: item[scoreKey] };
        }

        // Zero Score Logic (EPIC FAIL)
        if (item[scoreKey] === 0) {
            return { ...item, rank: 'EPIC FAIL', isFail: true, displayScore: item[scoreKey] };
        }

        // Calculate Rank
        // If exact tie with previous non-special item, share rank
        // We need to look back at previous items to find the last valid rank assignment
        // But simpler: just track the last score and rank assigned.

        let rankToAssign = currentRank;

        // Check if tied with PREVIOUS item (that wasn't special)
        // Note: Human Baseline is special, so we skip it for tie checks usually,
        // but here it's effectively removed from the rank counter flow or treated as separate.
        // Actually, "Human Baseline" has 100 score, so it will be at top.
        // The prompt says: "Human Baseline" ... received a rank of "-" and no medals or emojis.
        // It implies it doesn't consume a rank number? Or does it?
        // "The scores should be numbers in sequential order (1, 2, 3, 4...) individually."
        // If Human Baseline is top, and has "-", then the next one is 1? Or 2?
        // Usually baselines are outside the competition. I will assume it doesn't consume a rank.

        // Let's re-iterate to assign ranks properly
        return { ...item, rawScore: item[scoreKey] };
    }).map((item, index, array) => {
         if (item.rank === '-') return item; // Already processed Human Baseline
         if (item.rank === 'EPIC FAIL') return item; // Already processed Fail

         // Find rank
         // We filter out special items to determine the sequential rank index
         // But "sequential order (1, 2, 3, 4...)" implies competition ranking or dense ranking?
         // "There will be no ties between similar scores anymore. If, and only if, 2 models get the exact same score, only then they tie."
         // This implies Standard Competition Ranking (1224) or Dense Ranking (1223)?
         // "scores should be numbers in sequential order (1, 2, 3, 4...) individually" suggests Dense Ranking or just 1, 2, 3, 4 based on position if no ties?
         // If A=90, B=90, C=80.
         // Option A: 1, 1, 3 (Standard)
         // Option B: 1, 1, 2 (Dense)
         // The prompt says "sequential order... individually". This strongly suggests 1, 2, 3, 4... so if no ties, it's just index+1.
         // If ties: "only then they tie".
         // Let's assume Dense Ranking for "sequential order" preservation if ties exist?
         // Or maybe just Standard Ranking but ensuring we don't use the Z-test.
         // Let's look at "The scores should be numbers in sequential order (1, 2, 3, 4...)".
         // If A=10, B=10, C=5.
         // If I give 1, 1, 2 -> That is sequential (1, 2).
         // If I give 1, 1, 3 -> That skips 2.
         // So I will use Dense Ranking (1, 1, 2).

         // Check against previous item to see if tied
         // We need to find the "effective" previous item (ignoring Human Baseline)

         // Actually, let's simplify.
         // Filter out Human Baselines and Fails to determine ranks.
         return item;
    });
}

function processBenchmarks(items, scoreKey) {
     // 1. Sort by score descending
    let sorted = [...items].sort((a, b) => b[scoreKey] - a[scoreKey]);

    // 2. Separate 0 scores
    const nonZero = sorted.filter(item => item[scoreKey] > 0);
    const zeroScores = sorted.filter(item => item[scoreKey] === 0);
    zeroScores.sort((a, b) => a.name.localeCompare(b.name));

    const finalOrder = [...nonZero, ...zeroScores];

    let rankCounter = 1;
    let lastScore = -1;

    return finalOrder.map((item) => {
        // Special Case: Human Baseline
        if (item.name === 'Human Baseline') {
            return { ...item, rank: '-', isFail: false, displayScore: item[scoreKey] };
        }

        // Special Case: 0 Score
        if (item[scoreKey] === 0) {
            return { ...item, rank: 'EPIC FAIL', isFail: true, displayScore: item[scoreKey] };
        }

        // Regular Rank
        const score = item[scoreKey];
        if (score === lastScore) {
            // It's a tie with the previous rank assigned (since we are sorted)
            // rankCounter doesn't increment
        } else {
            // New score, increment rank if it's not the very first one (or first after baseline)
            // But wait, if Human Baseline was first, lastScore is -1.
            // If we have multiple different scores, we want 1, 2, 3...
            // If we have ties 1, 1, 2...

            // If this is the first item that gets a rank, it should be 1.
            // If previous was Human Baseline, this is still 1? Yes.
            if (lastScore !== -1) {
                 rankCounter++;
            }
        }

        lastScore = score;
        // Adjust for first item logic: if lastScore was -1 and we just set it, rankCounter is 1.
        // But if we had a tie at the top (unlikely but possible), rank is 1.

        // Wait, the logic above:
        // Item 1 (Score 90). lastScore=-1. score!=lastScore -> rankCounter++? No, rank starts at 1.
        // Let's reset the logic.

        return { ...item, rawScore: score };
    });
}

function computeRanks(items, scoreKey) {
    // 1. Sort
    let sorted = [...items].sort((a, b) => b[scoreKey] - a[scoreKey]);

    // 2. Separate Zeroes
    const eligible = sorted.filter(i => i[scoreKey] > 0);
    const fails = sorted.filter(i => i[scoreKey] === 0).sort((a,b) => a.name.localeCompare(b.name));

    // 3. Assign ranks to eligible
    let currentRank = 1;
    let previousScore = null;
    let rankedItems = [];

    eligible.forEach((item) => {
        if (item.name === 'Human Baseline') {
            rankedItems.push({ ...item, rank: '-', isFail: false });
            return;
        }

        const score = item[scoreKey];

        if (previousScore !== null && score < previousScore) {
            currentRank++;
        }

        rankedItems.push({ ...item, rank: currentRank, isFail: false });
        previousScore = score;
    });

    // 4. Append Fails
    fails.forEach(item => {
        rankedItems.push({ ...item, rank: 'EPIC FAIL', isFail: true });
    });

    return rankedItems;
}

// Easy Mode Logic (Averages)
const rawEasy = benchmarks.models.map(m => {
    const scores = Object.values(m.scores);
    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    return { ...m, avg };
});
const easyModeBenchmarks = computeRanks(rawEasy, 'avg');

// Hard Mode Logic
const hardModeBenchmarks = computeRanks(benchmarks.hardMode, 'score');

// Impossible Mode Logic
const impossibleModeBenchmarks = computeRanks(benchmarks.impossibleMode, 'score');

function getRankDisplay(rank) {
    if (rank === '-') return '-';
    if (rank === 'EPIC FAIL') return 'EPIC FAIL';
    if (rank === 1) return 'ðŸ¥‡';
    if (rank === 2) return 'ðŸ¥ˆ';
    if (rank === 3) return 'ðŸ¥‰';
    return `#${rank}`;
}
---

<Layout lang={lang} title={`${t.leaderboard_button} - ${t.title}`}>
    <main>
        <h1 id="leaderboard-title">{t.leaderboard_button}</h1>

        <div class="leaderboard-grid">
            <!-- Benchmarks Section -->
            <section class="leaderboard-section full-width">
                <h2 id="benchmark-title">{t.benchmark_title}</h2>

                <div class="benchmark-container">
                    <!-- Easy Mode -->
                     <div class="mode-header">
                        <h3>EASY MODE</h3>
                    </div>
                    <div class="benchmark-list">
                        {easyModeBenchmarks.map((m) => (
                            <div class={`benchmark-item ${m.isFail ? 'fail-item' : ''} ${m.name === 'Human Baseline' ? 'human-baseline' : ''}`}>
                                <div class={`rank ${m.isFail ? 'fail-rank' : ''}`}>
                                    {getRankDisplay(m.rank)}
                                </div>
                                <div class="model-info">
                                    <div class="model-name" data-release-date={m.releaseDate}>
                                        {m.name}
                                        {isNew(m.releaseDate) && <span class="new-badge">NEW</span>}
                                    </div>
                                </div>
                                <div class={`model-score ${m.isFail ? 'fail-score' : ''}`}>{m.avg.toFixed(1)}%</div>
                            </div>
                        ))}
                    </div>

                    <div class="spacer"></div>

                    <!-- Hard Mode -->
                    <div class="mode-header">
                        <h3>HARD MODE</h3>
                    </div>
                    <div class="benchmark-list">
                        {hardModeBenchmarks.map((m) => (
                            <div class={`benchmark-item ${m.isFail ? 'fail-item' : ''} ${m.name === 'Human Baseline' ? 'human-baseline' : ''}`}>
                                <div class={`rank ${m.isFail ? 'fail-rank' : ''}`}>
                                    {getRankDisplay(m.rank)}
                                </div>
                                <div class="model-info">
                                    <div class="model-name" data-release-date={m.releaseDate}>
                                        {m.name}
                                        {isNew(m.releaseDate) && <span class="new-badge">NEW</span>}
                                    </div>
                                </div>
                                <div class={`model-score ${m.isFail ? 'fail-score' : ''}`}>{m.score}%</div>
                            </div>
                        ))}
                    </div>

                    <div class="spacer"></div>

                    <!-- Impossible Mode -->
                    <div class="mode-header impossible-header">
                        <h3>IMPOSSIBLE MODE</h3>
                    </div>
                    <div class="benchmark-list">
                        {impossibleModeBenchmarks.map((m) => (
                            <div class={`benchmark-item ${m.isFail ? 'fail-item' : ''} ${m.name === 'Human Baseline' ? 'human-baseline' : ''}`}>
                                <div class={`rank ${m.isFail ? 'fail-rank' : ''} ${m.isFail ? '' : 'impossible-rank'}`}>
                                    {getRankDisplay(m.rank)}
                                </div>
                                <div class="model-info">
                                    <div class={`model-name ${m.isFail ? '' : 'impossible-text'}`} data-release-date={m.releaseDate}>
                                        {m.name}
                                        {isNew(m.releaseDate) && <span class="new-badge">NEW</span>}
                                    </div>
                                </div>
                                <div class={`model-score ${m.isFail ? 'fail-score' : 'impossible-score'}`}>{m.score}%</div>
                            </div>
                        ))}
                    </div>
                    <p class="disclaimer" id="benchmark-disclaimer">{t.benchmark_impossible_disclaimer}</p>
                    <p class="disclaimer contact-disclaimer" id="benchmark-contact">{t.benchmark_contact_disclaimer}</p>
                </div>
            </section>
        </div>
    </main>
</Layout>

<style>
    main {
        max-width: 80rem;
        margin: 4rem auto;
        padding: 0 1rem;
    }

    h1 {
        font-size: 3rem;
        font-weight: 900;
        text-align: center;
        margin-bottom: 3rem;
        color: white;
        background: linear-gradient(to right, #F59E0B, #EF4444);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    h2 {
        font-size: 2rem;
        font-weight: 700;
        color: white;
        margin-bottom: 1.5rem;
        text-align: center;
    }

    .mode-header h3 {
        font-size: 1.5rem;
        font-weight: 800;
        color: #F59E0B;
        margin-bottom: 1rem;
        border-bottom: 2px solid rgba(245, 158, 11, 0.3);
        padding-bottom: 0.5rem;
    }

    .spacer {
        height: 3rem;
    }

    .leaderboard-grid {
        display: flex; /* Changed from grid to flex to center the single column */
        justify-content: center;
    }

    .leaderboard-section.full-width {
        width: 100%;
        max-width: 800px; /* Limit width for readability */
    }

    .benchmark-container {
        background: rgba(31, 41, 55, 0.5);
        border-radius: 1rem;
        padding: 2rem;
        box-shadow: 0 0 30px rgba(0,0,0,0.2);
        border: 1px solid rgba(245, 158, 11, 0.3);
    }

    .benchmark-list {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .benchmark-item {
        display: flex;
        gap: 1rem;
        align-items: center;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .benchmark-item:last-child { border-bottom: none; padding-bottom: 0; }

    .rank {
        font-size: 1.5rem;
        font-weight: 900;
        color: #F59E0B;
        min-width: 50px;
        text-align: center;
        white-space: nowrap;
    }

    .human-baseline {
        opacity: 0.8;
    }

    .human-baseline .rank {
        color: #9CA3AF; /* Gray rank for baseline */
    }

    .fail-rank {
        color: #EF4444;
        font-size: 1.2rem; /* Slightly smaller to fit */
        min-width: 100px; /* More space for text */
    }

    .model-info {
        flex: 1;
    }

    .model-name {
        font-size: 1.1rem;
        font-weight: 700;
        color: white;
    }

    .model-score {
        font-size: 1.5rem;
        font-weight: 900;
        color: #F59E0B;
    }

    .fail-score {
        color: #6B7280; /* Dimmed score for fails */
    }

    /* Impossible Mode Styles */
    .impossible-header h3 {
        color: #ef4444;
        text-shadow:
            0 0 4px #7f1d1d,
            0 -5px 4px #ff9c00,
            2px -10px 6px #fd3e3e,
            -2px -15px 11px #f00;
        animation: burn 1.5s ease-in-out infinite alternate;
        border-color: #ef4444;
    }

    @keyframes burn {
        from { text-shadow: 0 0 4px #7f1d1d, 0 -5px 4px #ff9c00, 2px -10px 6px #fd3e3e, -2px -15px 11px #f00; }
        to { text-shadow: 0 0 4px #7f1d1d, 0 -2px 4px #ff9c00, 2px -5px 6px #fd3e3e, -2px -10px 11px #f00; }
    }

    .impossible-rank {
        color: #ef4444;
    }

    .impossible-score {
        color: #ef4444;
        text-shadow: 0 0 5px #7f1d1d;
    }

    .impossible-text {
        color: #fee2e2; /* Light red/white for contrast */
    }

    /* Override for Fail in Impossible Mode */
    .fail-item .impossible-score {
        color: #6B7280;
        text-shadow: none;
    }
    .fail-item .impossible-text {
         color: white; /* Reset to normal if it's a fail? Or keep it? Keeping it simple. */
    }

    /* New Badge Styles */
    .new-badge {
        display: inline-block;
        margin-left: 0.5rem;
        font-size: 0.7rem;
        font-weight: 800;
        color: #713f12; /* Dark gold text */
        background: linear-gradient(135deg, #fcd34d 0%, #f59e0b 100%);
        padding: 0.1rem 0.4rem;
        border-radius: 0.25rem;
        text-transform: uppercase;
        box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        animation: shine 2s infinite;
        vertical-align: middle;
        border: 1px solid #fbbf24;
    }

    @keyframes shine {
        0% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.05); }
        100% { opacity: 1; transform: scale(1); }
    }

    .disclaimer {
        margin-top: 2rem;
        font-size: 0.9rem;
        color: #9CA3AF;
        font-style: italic;
        text-align: center;
        opacity: 0.8;
    }

    .contact-disclaimer {
        margin-top: 1rem;
        color: #60A5FA;
    }
</style>

<script define:vars={{ translations, lang, TIME_OFFSET }}>
    function init() {
        // --- Translations ---
        let currentLang = lang;
        try {
            currentLang = localStorage.getItem('language') || document.cookie.split('; ').find(row => row.startsWith('language='))?.split('=')[1] || lang;
        } catch (e) {
            console.warn('Language detection failed:', e);
        }

        const t = translations[currentLang] || translations['en'];

        const mainTitle = document.getElementById('leaderboard-title');
        const benchTitle = document.getElementById('benchmark-title');
        const disclaimer = document.getElementById('benchmark-disclaimer');
        const contact = document.getElementById('benchmark-contact');

        if (mainTitle) mainTitle.textContent = t.leaderboard_button;
        if (benchTitle) benchTitle.textContent = t.benchmark_title;
        if (disclaimer) disclaimer.textContent = t.benchmark_impossible_disclaimer;
        if (contact) contact.textContent = t.benchmark_contact_disclaimer;

        // --- Dynamic "NEW" Badge Logic ---
        const timeOffset = TIME_OFFSET;
        const simNow = new Date(new Date().getTime() + timeOffset);

        document.querySelectorAll('.model-name[data-release-date]').forEach(el => {
            const dateStr = el.getAttribute('data-release-date');
            if (!dateStr) return;

            const release = new Date(dateStr);
            // Reset hours
            release.setHours(0,0,0,0);
            const today = new Date(simNow);
            today.setHours(0,0,0,0);

            const diffTime = today.getTime() - release.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            // Should be new if within 30 days
            const isNew = diffDays >= -1 && diffDays <= 30;

            let badge = el.querySelector('.new-badge');
            if (isNew) {
                if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'new-badge';
                    badge.textContent = 'NEW';
                    el.appendChild(badge);
                }
            } else {
                if (badge) badge.remove();
            }
        });
    }

    document.addEventListener('DOMContentLoaded', init);
</script>
