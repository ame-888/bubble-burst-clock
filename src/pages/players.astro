---
import Layout from '../layouts/Layout.astro';
import { predictions } from '../data/predictions';
import en from '../locales/en.json';
import ptBR from '../locales/pt-BR.json';
import ja from '../locales/ja.json';
import es from '../locales/es.json';
import zh from '../locales/zh.json';

const translations = {
    'en': en,
    'pt-BR': ptBR,
    'ja': ja,
    'es': es,
    'zh': zh,
};

const lang = 'en';
const t = translations[lang];

// --- Status Logic for counts ---
const now = new Date('2025-12-03T00:00:00Z');

const processedPredictions = predictions.map(p => {
    let status = 'FUTURE PREDICTION';
    const start = p.validityStart ? new Date(p.validityStart) : null;
    const end = p.validityEnd ? new Date(p.validityEnd) : null;

    if (start && end) {
        if (now < start) {
            status = 'FUTURE PREDICTION';
        } else if (now >= start && now <= end) {
            status = 'ACTIVE';
        } else {
            status = 'EXPIRED';
        }
    }
    return { ...p, status };
});

// --- Player Cards Logic ---
const creatorsData = {};
processedPredictions.forEach(p => {
    if (!creatorsData[p.creator]) {
        creatorsData[p.creator] = {
            name: p.creator,
            total: 0,
            failures: 0,
            pending: 0,
            successes: 0,
            predictions: []
        };
    }
    creatorsData[p.creator].total++;
    creatorsData[p.creator].predictions.push(p);

    if (p.status === 'EXPIRED') {
        creatorsData[p.creator].failures++;
    } else if (p.status === 'ACTIVE' || p.status === 'FUTURE PREDICTION') {
        creatorsData[p.creator].pending++;
    } else {
        creatorsData[p.creator].successes++;
    }
});

// Deterministic RPG Stats Generator
function getRPGStats(name) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
        hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const rng = (seed) => {
        const x = Math.sin(seed) * 10000;
        return Math.floor((Math.abs(x - Math.floor(x))) * 100); // 0-99
    };
    const scale = (val) => 10 + Math.floor(val * 0.89);

    return {
        STR: scale(rng(hash)),
        INT: scale(rng(hash + 1)),
        CHA: scale(rng(hash + 2)),
        LUCK: scale(rng(hash + 3))
    };
}

const players = Object.values(creatorsData).map(c => {
    // @ts-ignore
    const stats = getRPGStats(c.name);
    // Success Rate: (Success / (Success + Failure)) * 100. If 0 completed, 0%.
    // @ts-ignore
    const completed = c.successes + c.failures;
    // @ts-ignore
    const successRate = completed > 0 ? ((c.successes / completed) * 100).toFixed(0) : 0;

    // Assign a "Class" based on stats or name
    let rpgClass = "Doomer"; // Default
    if (stats.INT > 85) rpgClass = "Technomancer";
    else if (stats.CHA > 85) rpgClass = "Cult Leader";
    else if (stats.STR > 85) rpgClass = "Bubble Burster";
    else if (stats.LUCK > 85) rpgClass = "Oracle";

    // Rarity Map
    const rarityMap = {
        "Gary Marcus": "Legendary",
        "O Primo Rico": "Legendary",
        "Sabine Hossenfelder": "Legendary",
        "Adam Conover": "Epic",
        "Brianne Worth": "Epic",
        "Cole Hastings": "Epic",
        "Man Carrying Thing": "Epic",
        "Georg Rockall-Schmidt": "Epic",
        "Sasha Yanshin": "Epic",
        "OverEasy": "Rare",
        "Shade of Code": "Rare"
    };

    // @ts-ignore
    const rarity = rarityMap[c.name] || "Common";

    // MTG Color Mapping
    let mtgColor = "white"; // Doomer/Default
    if (rpgClass === "Technomancer") mtgColor = "blue";
    else if (rpgClass === "Cult Leader") mtgColor = "black";
    else if (rpgClass === "Bubble Burster") mtgColor = "red";
    else if (rpgClass === "Oracle") mtgColor = "green";

    // Flavor Text
    const flavorTextMap = {
        "Technomancer": "Logic is a prison waiting to be broken.",
        "Cult Leader": "Belief is the only currency that matters.",
        "Bubble Burster": "Reality has a way of asserting itself.",
        "Oracle": "I see what you refuse to acknowledge.",
        "Doomer": "The end is not near, it is here."
    };
    const flavorText = flavorTextMap[rpgClass] || "A watcher of the bubble.";

    // Last Entry Date (for sorting)
    const latestDate = Math.max(...c.predictions.map(p => {
        const d = p.uploadDate ? new Date(p.uploadDate) : new Date(0);
        return d.getTime();
    }));

    return { ...c, stats, successRate, rpgClass, rarity, mtgColor, flavorText, latestDate };
    // @ts-ignore
}).sort((a, b) => b.total - a.total); // Default sort
---

<Layout lang={lang} title={`${t.player_cards_title} - ${t.title}`}>
    <main>
        <h1 id="player-cards-title">{t.player_cards_title}</h1>

        <!-- Sorting Controls -->
        <div class="sort-controls">
            <label for="sort-select" class="sort-label">Sort by:</label>
            <select id="sort-select" class="sort-select">
                <option value="famous_desc">Most Famous</option>
                <option value="famous_asc">Least Famous</option>
                <option value="date_desc">Latest Entry</option>
                <option value="date_asc">Oldest Entry</option>
                <option value="name_asc">Name (A-Z)</option>
                <option value="name_desc">Name (Z-A)</option>
            </select>
        </div>

        <div class="player-container">
            <!-- Grid View -->
            <div id="player-grid-view" class="">
                <div class="player-grid" id="player-grid-container">
                    {players.map(player => (
                        <div class="player-card-mini"
                             data-player-name={player.name}
                             data-rarity={player.rarity}
                             data-mtg-color={player.mtgColor}
                             data-latest-date={player.latestDate}>

                             <!-- Mini MTG Card Structure -->
                             <div class={`mtg-card-container mini ${player.mtgColor.toLowerCase()} ${player.rarity.toLowerCase()}`}>
                                <div class="mtg-card-border">
                                    <div class="mtg-card-content">
                                        <!-- Header -->
                                        <div class="mtg-header">
                                            <span class="mtg-card-name">{player.name}</span>
                                            <span class="mtg-mana-cost">{player.total}</span>
                                        </div>

                                        <!-- Art -->
                                        <div class="mtg-art-frame">
                                            <div class="mtg-art-inner">
                                                <div class="rpg-avatar">{player.name.substring(0, 1).toUpperCase()}</div>
                                            </div>
                                        </div>

                                        <!-- Type Line -->
                                        <div class="mtg-type-line">
                                            <span class="type-text">{player.rpgClass}</span>
                                            <div class="mtg-set-symbol"></div>
                                        </div>

                                        <!-- Text Box -->
                                        <div class="mtg-text-box">
                                            <div class="mini-stats-grid">
                                                <span>STR: {player.stats.STR}</span>
                                                <span>INT: {player.stats.INT}</span>
                                                <span>CHA: {player.stats.CHA}</span>
                                                <span>LUCK: {player.stats.LUCK}</span>
                                            </div>
                                        </div>

                                        <!-- Footer -->
                                        <div class="mtg-footer">
                                            <div class="mtg-pt-box">
                                                {player.successes}/{player.total}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                             </div>

                        </div>
                    ))}
                </div>
            </div>

            <!-- Detail View -->
            <div id="player-detail-view" class="hidden">
                <div class="detail-nav-top">
                    <button id="back-to-grid" class="back-button">← Back</button>
                </div>

                <div class="detail-content-wrapper">
                    <button id="prev-card" class="nav-arrow side-arrow" aria-label="Previous">❮</button>

                    <div class="card-wrapper">
                        <div class="mtg-card-container detail-mode" id="mtg-card-container">
                            <!-- Dynamic classes for color/rarity will be added here via JS -->
                            <div class="mtg-card-border">
                                <div class="mtg-card-content">
                                    <!-- Header -->
                                    <div class="mtg-header">
                                        <div class="header-left">
                                            <span id="detail-name" class="mtg-card-name">Player Name</span>
                                            <button id="favorite-btn" class="favorite-star" title="Favorite this player">★</button>
                                        </div>
                                        <span id="detail-mana" class="mtg-mana-cost"></span>
                                    </div>

                                    <!-- Art -->
                                    <div class="mtg-art-frame">
                                        <div class="mtg-art-inner">
                                            <div class="rpg-avatar" id="detail-avatar"></div>
                                        </div>
                                    </div>

                                    <!-- Type Line -->
                                    <div class="mtg-type-line">
                                        <span id="detail-type-text">Legendary Creature — Class</span>
                                        <div id="detail-set-symbol" class="mtg-set-symbol"></div>
                                    </div>

                                    <!-- Text Box -->
                                    <div class="mtg-text-box">
                                        <ul id="detail-predictions-list" class="mtg-abilities-list">
                                            <!-- Populated by JS -->
                                        </ul>
                                        <div class="mtg-flavor-separator"></div>
                                        <div id="detail-flavor" class="mtg-flavor-text">
                                            "Flavor text goes here."
                                        </div>
                                    </div>

                                    <!-- Footer -->
                                    <div class="mtg-footer">
                                        <div class="mtg-pt-box">
                                            <span id="detail-pt">0 / 0</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button id="next-card" class="nav-arrow side-arrow" aria-label="Next">❯</button>
                </div>
            </div>
        </div>
    </main>
</Layout>

<style>
    main {
        max-width: 80rem;
        margin: 4rem auto;
        padding: 0 1rem;
    }

    h1 {
        font-size: 3rem;
        font-weight: 900;
        text-align: center;
        margin-bottom: 2rem;
        color: white;
        background: linear-gradient(to right, #10B981, #059669);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    /* Grid View */
    .sort-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 2rem;
        gap: 1rem;
    }

    .sort-label {
        color: #D1D5DB;
        font-weight: 600;
    }

    .sort-select {
        background: rgba(31, 41, 55, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        cursor: pointer;
        font-family: 'Inter', sans-serif;
    }

    .player-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 2rem;
        margin-top: 1.5rem;
        perspective: 1000px;
    }

    /* Wrapper for grid items */
    .player-card-mini {
        width: 100%;
        aspect-ratio: 2.5/3.5;
        cursor: pointer;
        transition: transform 0.3s ease;
    }
    .player-card-mini:hover {
        transform: translateY(-10px) rotateX(5deg);
        z-index: 10;
    }

    /* Detail View Utils */
    .hidden { display: none !important; }

    .detail-nav-top {
        margin-bottom: 1rem;
    }

    .detail-content-wrapper {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
    }

    .card-wrapper {
        flex: 1;
        max-width: 400px;
    }

    .back-button, .nav-arrow {
        background: rgba(31, 41, 55, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
    }

    .back-button:hover, .nav-arrow:hover {
        background: rgba(55, 65, 81, 0.8);
        border-color: #60A5FA;
    }

    .side-arrow {
        font-size: 1.5rem;
        padding: 0.5rem 1rem;
        height: fit-content;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .side-arrow:hover {
        background: rgba(0, 0, 0, 0.8);
    }

    /* Mobile responsiveness for arrows */
    @media (max-width: 600px) {
        .detail-content-wrapper {
            position: relative;
        }
        .side-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
            padding: 0.5rem 0.8rem;
        }
        #prev-card { left: -1rem; }
        #next-card { right: -1rem; }
    }
</style>

<script define:vars={{ translations, lang, players }}>
    // We need to inject the logic to handle the card interactions here
    // It is almost identical to the modal logic but scoped to this page

    function init() {
        let currentLang = lang;
        try {
            currentLang = localStorage.getItem('language') || document.cookie.split('; ').find(row => row.startsWith('language='))?.split('=')[1] || lang;
        } catch (e) {
            console.warn('Language detection failed:', e);
        }

        const t = translations[currentLang] || translations['en'];

        // Update title if needed
        const title = document.getElementById('player-cards-title');
        if (title) title.textContent = t.player_cards_title;

        // Interaction Logic
        const gridView = document.getElementById('player-grid-view');
        const detailView = document.getElementById('player-detail-view');
        const backBtn = document.getElementById('back-to-grid');
        const gridContainer = document.getElementById('player-grid-container');
        const sortSelect = document.getElementById('sort-select');
        const prevBtn = document.getElementById('prev-card');
        const nextBtn = document.getElementById('next-card');
        const favBtn = document.getElementById('favorite-btn');

        let currentSortedPlayers = [...players];
        let currentIndex = -1;

        // Favorite Logic
        function isFavorite(name) {
            try {
                return localStorage.getItem('favorite_player') === name;
            } catch (e) { return false; }
        }

        function setFavorite(name) {
            try {
                if (isFavorite(name)) {
                    localStorage.removeItem('favorite_player');
                    updateFavBtn(false);
                } else {
                    localStorage.setItem('favorite_player', name);
                    updateFavBtn(true);

                    // Unlock "Stan" Achievement
                    if (window.AchievementManager) {
                        window.AchievementManager.unlock('stan');
                    }
                }
            } catch (e) {}
        }

        function updateFavBtn(isFav) {
            if (!favBtn) return;
            if (isFav) {
                favBtn.classList.add('active');
            } else {
                favBtn.classList.remove('active');
            }
        }

        if (favBtn) {
            favBtn.addEventListener('click', () => {
                if (currentIndex >= 0 && currentSortedPlayers[currentIndex]) {
                    setFavorite(currentSortedPlayers[currentIndex].name);
                }
            });
        }

        // Rarity Priority Map for Sorting
        const rarityVal = { "Legendary": 4, "Epic": 3, "Rare": 2, "Common": 1 };

        function updateGrid() {
            if (!gridContainer) return;
            gridContainer.innerHTML = '';

            // Re-render based on sorted list
            currentSortedPlayers.forEach(player => {
                const div = document.createElement('div');
                div.className = 'player-card-mini';
                div.dataset.playerName = player.name;
                div.dataset.rarity = player.rarity;
                div.dataset.mtgColor = player.mtgColor;
                div.dataset.latestDate = player.latestDate;

                // Mini MTG Card HTML Construction
                div.innerHTML = `
                    <div class="mtg-card-container mini ${player.mtgColor.toLowerCase()} ${player.rarity.toLowerCase()}">
                        <div class="mtg-card-border">
                            <div class="mtg-card-content">
                                <div class="mtg-header">
                                    <span class="mtg-card-name">${player.name}</span>
                                    <span class="mtg-mana-cost">${player.total}</span>
                                </div>
                                <div class="mtg-art-frame">
                                    <div class="mtg-art-inner">
                                        <div class="rpg-avatar">${player.name.substring(0, 1).toUpperCase()}</div>
                                    </div>
                                </div>
                                <div class="mtg-type-line">
                                    <span class="type-text">${player.rpgClass}</span>
                                    <div class="mtg-set-symbol"></div>
                                </div>
                                <div class="mtg-text-box">
                                    <div class="mini-stats-grid">
                                        <span>STR: ${player.stats.STR}</span>
                                        <span>INT: ${player.stats.INT}</span>
                                        <span>CHA: ${player.stats.CHA}</span>
                                        <span>LUCK: ${player.stats.LUCK}</span>
                                    </div>
                                </div>
                                <div class="mtg-footer">
                                    <div class="mtg-pt-box">
                                        ${player.successes}/${player.total}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                div.addEventListener('click', () => openDetail(player.name));
                gridContainer.appendChild(div);
            });
        }

        function sortPlayers(mode) {
            if (mode === 'famous_desc') {
                currentSortedPlayers.sort((a, b) => (rarityVal[b.rarity] || 1) - (rarityVal[a.rarity] || 1));
            } else if (mode === 'famous_asc') {
                currentSortedPlayers.sort((a, b) => (rarityVal[a.rarity] || 1) - (rarityVal[b.rarity] || 1));
            } else if (mode === 'date_desc') {
                currentSortedPlayers.sort((a, b) => b.latestDate - a.latestDate);
            } else if (mode === 'date_asc') {
                currentSortedPlayers.sort((a, b) => a.latestDate - b.latestDate);
            } else if (mode === 'name_asc') {
                currentSortedPlayers.sort((a, b) => a.name.localeCompare(b.name));
            } else if (mode === 'name_desc') {
                currentSortedPlayers.sort((a, b) => b.name.localeCompare(a.name));
            }
            updateGrid();
        }

        if (sortSelect) {
            sortSelect.addEventListener('change', (e) => sortPlayers(e.target.value));
            // Initial sort
            sortPlayers(sortSelect.value);
        }

        function openDetail(name) {
             const index = currentSortedPlayers.findIndex(p => p.name === name);
             if (index === -1) return;
             currentIndex = index;
             renderDetail(currentSortedPlayers[currentIndex]);

             gridView.classList.add('hidden');
             detailView.classList.remove('hidden');
        }

        function renderDetail(player) {
            // Populate Detail View (MTG Style)
            const dName = document.getElementById('detail-name');
            if (dName) dName.textContent = player.name;

            const dType = document.getElementById('detail-type-text');
            if (dType) dType.textContent = `${player.rarity} ${player.rpgClass}`;

            const dMana = document.getElementById('detail-mana');
            if (dMana) dMana.textContent = player.total;

            const dAvatar = document.getElementById('detail-avatar');
            if (dAvatar) dAvatar.textContent = player.name.substring(0, 1).toUpperCase();

            const dPt = document.getElementById('detail-pt');
            if (dPt) dPt.textContent = `${player.successes}/${player.total}`;

            const dFlavor = document.getElementById('detail-flavor');
            if (dFlavor) dFlavor.textContent = `"${player.flavorText}"`;

            // Update Lists
            const list = document.getElementById('detail-predictions-list');
            if (list) {
                list.innerHTML = '';
                player.predictions.forEach(p => {
                    const li = document.createElement('li');

                    // Localize claim if object
                    let claimText = '';
                    if (typeof p.claim === 'string') claimText = p.claim;
                    else if (typeof p.claim === 'object') claimText = p.claim[currentLang] || p.claim['en'];

                    let bulletColorClass = 'bullet-future';
                    if (p.status === 'ACTIVE') bulletColorClass = 'bullet-active';
                    if (p.status === 'EXPIRED') bulletColorClass = 'bullet-expired';

                    // Use a colored bullet point instead of text label
                    li.innerHTML = `<span class="mtg-ability-bullet ${bulletColorClass}">●</span> <span>${claimText}</span>`;
                    list.appendChild(li);
                });
            }

            // Apply Styles
            const container = document.getElementById('mtg-card-container');
            if (container) {
                container.className = 'mtg-card-container detail-mode'; // Reset
                container.classList.add(player.mtgColor.toLowerCase());
                container.classList.add(player.rarity.toLowerCase());
            }

             // Update Favorite Button State
             updateFavBtn(isFavorite(player.name));
        }

        if (backBtn && gridView && detailView) {
            backBtn.addEventListener('click', () => {
                detailView.classList.add('hidden');
                gridView.classList.remove('hidden');
            });
        }

        if (prevBtn) {
            prevBtn.addEventListener('click', () => {
                if (currentIndex > 0) {
                    currentIndex--;
                    renderDetail(currentSortedPlayers[currentIndex]);
                } else {
                    // Loop to end
                    currentIndex = currentSortedPlayers.length - 1;
                    renderDetail(currentSortedPlayers[currentIndex]);
                }
            });
        }

        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                if (currentIndex < currentSortedPlayers.length - 1) {
                    currentIndex++;
                    renderDetail(currentSortedPlayers[currentIndex]);
                } else {
                    // Loop to start
                    currentIndex = 0;
                    renderDetail(currentSortedPlayers[currentIndex]);
                }
            });
        }
    }

    document.addEventListener('DOMContentLoaded', init);
</script>
