---
---
<div id="game-center-container">
    <button id="joystick-btn" aria-label="Open Game Center" title="Play Games">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="joystick-icon">
            <rect x="2" y="6" width="20" height="12" rx="2"></rect>
            <path d="M6 12h4"></path>
            <path d="M8 10v4"></path>
            <line x1="15" y1="13" x2="15.01" y2="13"></line>
            <line x1="18" y1="11" x2="18.01" y2="11"></line>
        </svg>
    </button>

    <div id="game-modal" class="hidden">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Arcade Center</h2>
                <button id="close-modal-btn" aria-label="Close">&times;</button>
            </div>

            <div id="game-menu">
                <button class="game-select-btn" data-game="tetris">
                    <span class="game-icon">üß±</span> Tetris
                </button>
                <button class="game-select-btn" data-game="snake">
                    <span class="game-icon">üêç</span> Snake
                </button>
                <button class="game-select-btn" data-game="tictactoe">
                    <span class="game-icon">‚ùå</span> Tic-Tac-Toe
                </button>
                <button class="game-select-btn" id="leaderboard-btn" style="margin-top: 1rem; border-color: #F59E0B; color: #F59E0B;">
                    <span class="game-icon">üèÜ</span> High Scores
                </button>
            </div>

            <div id="leaderboard-view" class="hidden">
                <h3>Top Scores</h3>
                <div id="leaderboard-content"></div>
                <button id="back-from-leaderboard-btn" class="menu-back-btn">‚Üê Back to Menu</button>
            </div>

            <div id="game-area" class="hidden">
                <!-- Tetris -->
                <div id="tetris-container" class="game-container hidden">
                    <div class="scanline"></div>
                    <canvas id="tetris-canvas" width="200" height="400"></canvas>
                    <div class="game-info">
                        <div class="score-display">Score: <span id="tetris-score">0</span></div>
                        <p class="controls-hint">‚Üê ‚Üí Move, ‚Üë Rotate, ‚Üì Drop</p>
                        <button class="restart-btn" id="restart-tetris">Restart Game</button>
                    </div>
                </div>

                <!-- Snake -->
                <div id="snake-container" class="game-container hidden">
                     <div class="scanline"></div>
                    <canvas id="snake-canvas" width="400" height="300"></canvas>
                    <div class="game-info">
                        <div class="score-display">Score: <span id="snake-score">0</span></div>
                        <p class="controls-hint">Arrow Keys to Move</p>
                        <button class="restart-btn" id="restart-snake">Restart Game</button>
                    </div>
                </div>

                <!-- Tic-Tac-Toe -->
                <div id="tictactoe-container" class="game-container hidden">
                    <div id="tictactoe-board"></div>
                    <div class="game-info">
                        <div id="tictactoe-status" class="status-msg">Player X Turn</div>
                        <button class="restart-btn" id="restart-tictactoe">Restart Game</button>
                    </div>
                </div>

                <button id="back-to-menu-btn" class="menu-back-btn">‚Üê Back to Menu</button>
            </div>
        </div>
    </div>
</div>

<style>
    .hidden {
        display: none !important;
    }

    #joystick-btn {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 40;
        background-color: #374151;
        color: white;
        border: 1px solid #4B5563;
        border-radius: 50%;
        width: 3rem;
        height: 3rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    #joystick-btn:hover {
        background-color: #4B5563;
        transform: scale(1.1);
    }

    .joystick-icon {
        width: 1.5rem;
        height: 1.5rem;
    }

    #game-modal {
        position: fixed;
        inset: 0;
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #game-modal.hidden {
        display: none;
    }

    .modal-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(4px);
    }

    .modal-content {
        position: relative;
        background-color: #1F2937;
        border: 1px solid #374151;
        border-radius: 0.75rem;
        padding: 1.5rem;
        width: 90%;
        max-width: 500px;
        color: white;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        max-height: 90vh;
        overflow-y: auto;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #374151;
        padding-bottom: 1rem;
    }

    #modal-title {
        font-size: 1.5rem;
        font-weight: bold;
        color: #F3F4F6;
        margin: 0;
    }

    #close-modal-btn {
        background: none;
        border: none;
        color: #9CA3AF;
        font-size: 2rem;
        line-height: 1;
        cursor: pointer;
        padding: 0;
    }

    #close-modal-btn:hover {
        color: white;
    }

    #game-menu {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .game-select-btn {
        background-color: #374151;
        border: 1px solid #4B5563;
        padding: 1rem;
        border-radius: 0.5rem;
        color: white;
        font-size: 1.25rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        transition: all 0.2s;
    }

    .game-select-btn:hover {
        background-color: #4B5563;
        transform: translateY(-2px);
    }

    .game-icon {
        font-size: 1.5rem;
    }

    #game-area.hidden {
        display: none;
    }

    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
    }

    .game-container.hidden {
        display: none;
    }

    canvas {
        background-color: #111827;
        border: 2px solid #4B5563;
        border-radius: 0.25rem;
        max-width: 100%;
    }

    .game-info {
        text-align: center;
        width: 100%;
    }

    .score-display {
        font-size: 1.25rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: #60A5FA;
    }

    .controls-hint {
        color: #9CA3AF;
        font-size: 0.875rem;
        margin-bottom: 1rem;
    }

    .restart-btn {
        background-color: #DC2626;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-weight: 600;
        transition: background-color 0.2s;
    }

    .restart-btn:hover {
        background-color: #B91C1C;
    }

    .menu-back-btn {
        margin-top: 1.5rem;
        background: none;
        border: none;
        color: #9CA3AF;
        cursor: pointer;
        font-size: 0.875rem;
        text-decoration: underline;
        width: 100%;
        text-align: center;
    }

    .menu-back-btn:hover {
        color: white;
    }

    #leaderboard-view h3 {
        text-align: center;
        color: #F59E0B;
        margin-top: 0;
    }

    .leaderboard-game-section {
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #374151;
        padding-bottom: 0.5rem;
    }

    .leaderboard-game-title {
        font-weight: bold;
        color: #60A5FA;
        margin-bottom: 0.5rem;
    }

    .leaderboard-list {
        list-style: none;
        padding: 0;
        margin: 0;
        font-size: 0.9rem;
    }

    .leaderboard-list li {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.25rem;
        color: #D1D5DB;
    }

    /* CRT Scanline Effect */
    .scanline {
        width: 100%;
        height: 100px;
        z-index: 10;
        background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 255, 255, 0.05) 50%, rgba(0,0,0,0) 100%);
        opacity: 0.1;
        position: absolute;
        bottom: 100%;
        pointer-events: none;
        animation: scanline 10s linear infinite;
    }
    @keyframes scanline {
        0% { bottom: 100%; }
        100% { bottom: -100%; }
    }

    .game-container {
        position: relative;
        overflow: hidden; /* For scanline */
    }

    canvas {
        box-shadow: 0 0 10px rgba(96, 165, 250, 0.2), inset 0 0 20px rgba(0,0,0,0.5);
        border: 2px solid #60A5FA;
    }

    /* Tic-Tac-Toe Specific */
    #tictactoe-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        background-color: #4B5563;
        padding: 0.5rem;
        border-radius: 0.5rem;
    }

    .ttt-cell {
        width: 4rem;
        height: 4rem;
        background-color: #1F2937;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.5rem;
        font-weight: bold;
        color: white;
        cursor: pointer;
        user-select: none;
    }

    .ttt-cell:hover {
        background-color: #374151;
    }

    .ttt-cell.x { color: #60A5FA; }
    .ttt-cell.o { color: #F87171; }

    .status-msg {
        font-size: 1.25rem;
        margin-bottom: 1rem;
        font-weight: bold;
    }

</style>

<script>
    import { SoundManager, ScoreManager } from '../scripts/GameUtils.js';

    // --- Utilities ---
    const soundManager = new SoundManager();
    const scoreManager = new ScoreManager();

    // --- State Management ---
    let currentGame = null;
    let gameLoopId = null;

    // --- DOM Elements ---
    const joystickBtn = document.getElementById('joystick-btn');
    const modal = document.getElementById('game-modal');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const gameMenu = document.getElementById('game-menu');
    const gameArea = document.getElementById('game-area');
    const backToMenuBtn = document.getElementById('back-to-menu-btn');
    const gameButtons = document.querySelectorAll('.game-select-btn');
    const leaderboardBtn = document.getElementById('leaderboard-btn');
    const backFromLeaderboardBtn = document.getElementById('back-from-leaderboard-btn');
    const leaderboardView = document.getElementById('leaderboard-view');
    const leaderboardContent = document.getElementById('leaderboard-content');

    // --- Event Listeners ---
    joystickBtn.addEventListener('click', openModal);
    closeModalBtn.addEventListener('click', closeModal);
    backToMenuBtn.addEventListener('click', showMenu);
    backFromLeaderboardBtn.addEventListener('click', showMenu);

    leaderboardBtn.addEventListener('click', showLeaderboard);

    gameButtons.forEach(btn => {
        if (btn.id === 'leaderboard-btn') return;
        btn.addEventListener('click', () => {
            const gameName = btn.dataset.game;
            startGame(gameName);
        });
    });

    document.getElementById('restart-tetris').addEventListener('click', () => initTetris());
    document.getElementById('restart-snake').addEventListener('click', () => initSnake());
    document.getElementById('restart-tictactoe').addEventListener('click', () => initTicTacToe());

    // --- Modal Logic ---
    function openModal() {
        modal.classList.remove('hidden');
        showMenu();
    }

    function closeModal() {
        modal.classList.add('hidden');
        stopGameLoop();
        currentGame = null;
    }

    function showMenu() {
        stopGameLoop();
        gameMenu.classList.remove('hidden');
        gameArea.classList.add('hidden');
        leaderboardView.classList.add('hidden');
        document.querySelectorAll('.game-container').forEach(el => el.classList.add('hidden'));
        document.getElementById('modal-title').textContent = "Arcade Center";
    }

    function showLeaderboard() {
        gameMenu.classList.add('hidden');
        leaderboardView.classList.remove('hidden');
        document.getElementById('modal-title').textContent = "Hall of Fame";

        const scores = scoreManager.getScores();
        let html = '';

        // Tetris
        html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Tetris</div><ul class="leaderboard-list">`;
        if (scores.tetris && scores.tetris.length) {
            scores.tetris.forEach(s => html += `<li><span>${new Date(s.date).toLocaleDateString()}</span><span>${s.score}</span></li>`);
        } else {
            html += `<li>No scores yet</li>`;
        }
        html += `</ul></div>`;

        // Snake
        html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Snake</div><ul class="leaderboard-list">`;
        if (scores.snake && scores.snake.length) {
            scores.snake.forEach(s => html += `<li><span>${new Date(s.date).toLocaleDateString()}</span><span>${s.score}</span></li>`);
        } else {
            html += `<li>No scores yet</li>`;
        }
        html += `</ul></div>`;

        // Tic-Tac-Toe
        html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Tic-Tac-Toe (Max Streak)</div><ul class="leaderboard-list">`;
        html += `<li><span>Current Best Streak</span><span>${scores.tictactoe || 0}</span></li>`;
        html += `</ul></div>`;

        leaderboardContent.innerHTML = html;
    }

    function startGame(gameName) {
        gameMenu.classList.add('hidden');
        gameArea.classList.remove('hidden');
        leaderboardView.classList.add('hidden');
        currentGame = gameName;

        document.querySelectorAll('.game-container').forEach(el => el.classList.add('hidden'));

        if (gameName === 'tetris') {
            document.getElementById('tetris-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Tetris";
            initTetris();
        } else if (gameName === 'snake') {
            document.getElementById('snake-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Snake";
            initSnake();
        } else if (gameName === 'tictactoe') {
            document.getElementById('tictactoe-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Tic-Tac-Toe";
            initTicTacToe();
        }
    }

    function stopGameLoop() {
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
        }
    }

    // ==========================================
    // TIC-TAC-TOE
    // ==========================================
    let tttBoard = Array(9).fill(null);
    let tttPlayer = 'X';
    let tttActive = true;
    let tttStreak = 0;

    function initTicTacToe() {
        tttBoard = Array(9).fill(null);
        tttPlayer = 'X';
        tttActive = true;
        tttStreak = 0;
        updateTicTacToeUI();
    }

    function updateTicTacToeUI() {
        const boardEl = document.getElementById('tictactoe-board');
        boardEl.innerHTML = '';
        const statusEl = document.getElementById('tictactoe-status');

        tttBoard.forEach((cell, index) => {
            const cellEl = document.createElement('div');
            cellEl.classList.add('ttt-cell');
            if (cell) cellEl.classList.add(cell.toLowerCase());
            cellEl.textContent = cell || '';
            cellEl.addEventListener('click', () => handleTicTacToeClick(index));
            boardEl.appendChild(cellEl);
        });

        const winner = checkTicTacToeWin();
        if (winner) {
            statusEl.textContent = `Player ${winner} Wins!`;
            tttActive = false;

            if (winner === 'X') {
                soundManager.play('win');
                tttStreak++;
                const isHigh = scoreManager.saveScore('tictactoe', tttStreak);
                if (isHigh) {
                    statusEl.textContent += " (New Record!)";
                }
            } else {
                soundManager.play('gameover');
                tttStreak = 0; // Reset streak on loss
            }

        } else if (!tttBoard.includes(null)) {
            statusEl.textContent = "It's a Draw!";
            soundManager.play('gameover');
            tttActive = false;
        } else {
            statusEl.textContent = `Player ${tttPlayer}'s Turn`;
        }
    }

    function handleTicTacToeClick(index) {
        if (!tttActive || tttBoard[index] || tttPlayer !== 'X') return;

        // Player Move
        tttBoard[index] = 'X';
        soundManager.play('click');

        if (checkTicTacToeWin() || !tttBoard.includes(null)) {
            updateTicTacToeUI();
            return;
        }

        tttPlayer = 'O';
        updateTicTacToeUI();

        // CPU Move
        setTimeout(() => {
            if (!tttActive) return;
            makeCPUMove();
            if (!checkTicTacToeWin()) {
                tttPlayer = 'X';
            }
            updateTicTacToeUI();
        }, 500);
    }

    function makeCPUMove() {
        const emptyIndices = tttBoard.map((val, idx) => val === null ? idx : null).filter(val => val !== null);
        if (emptyIndices.length > 0) {
            const randomIdx = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
            tttBoard[randomIdx] = 'O';
            soundManager.play('move');
        }
    }

    function checkTicTacToeWin() {
        const wins = [
            [0,1,2], [3,4,5], [6,7,8], // Rows
            [0,3,6], [1,4,7], [2,5,8], // Cols
            [0,4,8], [2,4,6]           // Diags
        ];

        for (const combo of wins) {
            const [a, b, c] = combo;
            if (tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c]) {
                return tttBoard[a];
            }
        }
        return null;
    }

    // ==========================================
    // SNAKE
    // ==========================================
    let snakeCanvas, snakeCtx;
    let snake = [];
    let snakeFood = {};
    let snakeDir = 'right';
    let snakeNextDir = 'right';
    let snakeScore = 0;
    let snakeLastTime = 0;
    let snakeSpeed = 100;
    let snakeAccumulator = 0;
    const snakeGrid = 20;

    function initSnake() {
        stopGameLoop();
        snakeCanvas = document.getElementById('snake-canvas');
        snakeCtx = snakeCanvas.getContext('2d');

        // Ensure compact size
        snakeCanvas.width = 400;
        snakeCanvas.height = 300; // Reduced height to fit better

        snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
        snakeDir = 'right';
        snakeNextDir = 'right';
        snakeScore = 0;
        snakeSpeed = 100;
        document.getElementById('snake-score').textContent = snakeScore;
        placeSnakeFood();

        snakeLastTime = 0;
        snakeAccumulator = 0;

        gameLoopId = requestAnimationFrame(gameLoopSnake);
        document.addEventListener('keydown', handleSnakeInput);
    }

    function gameLoopSnake(time) {
        if (currentGame !== 'snake') return;

        const deltaTime = time - snakeLastTime;
        snakeLastTime = time;
        snakeAccumulator += deltaTime;

        if (snakeAccumulator > snakeSpeed) {
            updateSnake();
            snakeAccumulator = 0;
        }

        drawSnake();
        gameLoopId = requestAnimationFrame(gameLoopSnake);
    }

    function handleSnakeInput(e) {
        if (currentGame !== 'snake') return;

        // Prevent default scrolling for arrow keys
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        switch(e.key) {
            case 'ArrowUp':
                if (snakeDir !== 'down') snakeNextDir = 'up';
                soundManager.play('move');
                break;
            case 'ArrowDown':
                if (snakeDir !== 'up') snakeNextDir = 'down';
                soundManager.play('move');
                break;
            case 'ArrowLeft':
                if (snakeDir !== 'right') snakeNextDir = 'left';
                soundManager.play('move');
                break;
            case 'ArrowRight':
                if (snakeDir !== 'left') snakeNextDir = 'right';
                soundManager.play('move');
                break;
        }
    }

    function placeSnakeFood() {
        snakeFood = {
            x: Math.floor(Math.random() * (snakeCanvas.width / snakeGrid)),
            y: Math.floor(Math.random() * (snakeCanvas.height / snakeGrid))
        };
        // Ensure food doesn't spawn on snake
        if (snake.some(seg => seg.x === snakeFood.x && seg.y === snakeFood.y)) {
            placeSnakeFood();
        }
    }

    function updateSnake() {
        snakeDir = snakeNextDir;
        const head = { ...snake[0] };

        if (snakeDir === 'right') head.x++;
        if (snakeDir === 'left') head.x--;
        if (snakeDir === 'up') head.y--;
        if (snakeDir === 'down') head.y++;

        // Wall Collision
        if (head.x < 0 || head.x >= snakeCanvas.width / snakeGrid ||
            head.y < 0 || head.y >= snakeCanvas.height / snakeGrid ||
            snake.some(seg => seg.x === head.x && seg.y === head.y)) {
            gameOverSnake();
            return;
        }

        snake.unshift(head);

        if (head.x === snakeFood.x && head.y === snakeFood.y) {
            snakeScore += 10;
            // Speed up slightly
            if (snakeSpeed > 50) snakeSpeed -= 1;

            document.getElementById('snake-score').textContent = snakeScore;
            soundManager.play('eat');
            placeSnakeFood();
        } else {
            snake.pop();
        }
    }

    function drawSnake() {
        // Clear
        snakeCtx.fillStyle = '#111827';
        snakeCtx.fillRect(0, 0, snakeCanvas.width, snakeCanvas.height);

        // Grid lines
        snakeCtx.strokeStyle = '#1F2937';
        snakeCtx.lineWidth = 1;
        for (let x = 0; x <= snakeCanvas.width; x += snakeGrid) {
            snakeCtx.beginPath();
            snakeCtx.moveTo(x, 0);
            snakeCtx.lineTo(x, snakeCanvas.height);
            snakeCtx.stroke();
        }
        for (let y = 0; y <= snakeCanvas.height; y += snakeGrid) {
            snakeCtx.beginPath();
            snakeCtx.moveTo(0, y);
            snakeCtx.lineTo(snakeCanvas.width, y);
            snakeCtx.stroke();
        }

        // Food
        snakeCtx.fillStyle = '#EF4444';
        snakeCtx.shadowBlur = 10;
        snakeCtx.shadowColor = '#EF4444';
        snakeCtx.fillRect(snakeFood.x * snakeGrid, snakeFood.y * snakeGrid, snakeGrid - 2, snakeGrid - 2);
        snakeCtx.shadowBlur = 0;

        // Snake
        snakeCtx.shadowBlur = 5;
        snakeCtx.shadowColor = '#10B981';
        snake.forEach((seg, index) => {
            snakeCtx.fillStyle = index === 0 ? '#34D399' : '#10B981'; // Head is brighter
            snakeCtx.fillRect(seg.x * snakeGrid, seg.y * snakeGrid, snakeGrid - 2, snakeGrid - 2);
        });
        snakeCtx.shadowBlur = 0;
    }

    function gameOverSnake() {
        stopGameLoop();
        soundManager.play('gameover');
        scoreManager.saveScore('snake', snakeScore);

        snakeCtx.fillStyle = 'white';
        snakeCtx.font = '30px sans-serif';
        snakeCtx.textAlign = 'center';
        snakeCtx.fillText("Game Over", snakeCanvas.width / 2, snakeCanvas.height / 2);
    }

    // ==========================================
    // TETRIS
    // ==========================================
    const tetrisCols = 10;
    const tetrisRows = 20;
    const blockSize = 20; // Reduced to 20px to fit 200x400 canvas
    let tetrisCanvas, tetrisCtx;
    let tetrisBoard = [];
    let tetrisScore = 0;
    let currentPiece = null;
    let lastTime = 0;
    let dropCounter = 0;
    let dropInterval = 1000;

    const pieces = 'ILJOTSZ';
    const shapes = {
        'I': [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
        'L': [[0,0,1], [1,1,1], [0,0,0]],
        'J': [[1,0,0], [1,1,1], [0,0,0]],
        'O': [[1,1], [1,1]],
        'Z': [[1,1,0], [0,1,1], [0,0,0]],
        'S': [[0,1,1], [1,1,0], [0,0,0]],
        'T': [[0,1,0], [1,1,1], [0,0,0]]
    };
    const colors = {
        'I': '#06B6D4', 'O': '#F59E0B', 'T': '#8B5CF6',
        'S': '#10B981', 'Z': '#EF4444', 'J': '#3B82F6', 'L': '#F97316'
    };

    function initTetris() {
        stopGameLoop();
        tetrisCanvas = document.getElementById('tetris-canvas');
        tetrisCtx = tetrisCanvas.getContext('2d');
        tetrisCtx.scale(1, 1);

        // Resize canvas to match new block size * rows/cols
        tetrisCanvas.width = tetrisCols * blockSize;
        tetrisCanvas.height = tetrisRows * blockSize;

        tetrisBoard = Array(tetrisRows).fill().map(() => Array(tetrisCols).fill(0));
        tetrisScore = 0;
        document.getElementById('tetris-score').textContent = tetrisScore;

        resetPiece();
        dropCounter = 0;
        lastTime = 0;

        gameLoopId = requestAnimationFrame(updateTetris);
        document.addEventListener('keydown', handleTetrisInput);
    }

    function resetPiece() {
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        currentPiece = {
            matrix: shapes[type],
            pos: {x: Math.floor(tetrisCols / 2) - 1, y: 0},
            type: type
        };
        if (collide(tetrisBoard, currentPiece)) {
            // Game Over
            soundManager.play('gameover');
            scoreManager.saveScore('tetris', tetrisScore);
            tetrisBoard.forEach(row => row.fill(0));
            tetrisScore = 0;
            resetPiece();
        }
    }

    function collide(board, piece) {
        const m = piece.matrix;
        const o = piece.pos;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 &&
                   (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    const color = typeof value === 'string' ? colors[value] : colors[currentPiece.type];
                    tetrisCtx.fillStyle = color;
                    tetrisCtx.shadowBlur = 15;
                    tetrisCtx.shadowColor = color;
                    tetrisCtx.fillRect((x + offset.x) * blockSize, (y + offset.y) * blockSize, blockSize - 1, blockSize - 1);
                    tetrisCtx.shadowBlur = 0;
                }
            });
        });
    }

    function drawTetris() {
        if (!tetrisCtx) return;
        tetrisCtx.fillStyle = '#111827';
        tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);

        // Grid lines for retro feel
        tetrisCtx.strokeStyle = '#1F2937';
        tetrisCtx.lineWidth = 1;
        for (let i = 0; i <= tetrisCols; i++) {
            tetrisCtx.beginPath();
            tetrisCtx.moveTo(i * blockSize, 0);
            tetrisCtx.lineTo(i * blockSize, tetrisCanvas.height);
            tetrisCtx.stroke();
        }
        for (let i = 0; i <= tetrisRows; i++) {
            tetrisCtx.beginPath();
            tetrisCtx.moveTo(0, i * blockSize);
            tetrisCtx.lineTo(tetrisCanvas.width, i * blockSize);
            tetrisCtx.stroke();
        }

        // Draw Ghost Piece
        if (currentPiece) {
            const ghostPos = { ...currentPiece.pos };
            while (!collide(tetrisBoard, { matrix: currentPiece.matrix, pos: ghostPos, type: currentPiece.type })) {
                ghostPos.y++;
            }
            ghostPos.y--;

            currentPiece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        tetrisCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        tetrisCtx.lineWidth = 1;
                        tetrisCtx.strokeRect((x + ghostPos.x) * blockSize, (y + ghostPos.y) * blockSize, blockSize - 1, blockSize - 1);
                    }
                });
            });

            drawMatrix(tetrisBoard, {x: 0, y: 0});
            drawMatrix(currentPiece.matrix, currentPiece.pos);
        }
    }

    function merge(board, piece) {
        piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    board[y + piece.pos.y][x + piece.pos.x] = piece.type;
                }
            });
        });
    }

    function rotate(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        if (dir > 0) matrix.forEach(row => row.reverse());
        else matrix.reverse();
    }

    function playerRotate(dir) {
        const pos = currentPiece.pos.x;
        let offset = 1;
        rotate(currentPiece.matrix, dir);
        while (collide(tetrisBoard, currentPiece)) {
            currentPiece.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > currentPiece.matrix[0].length) {
                rotate(currentPiece.matrix, -dir);
                currentPiece.pos.x = pos;
                return;
            }
        }
    }

    function arenaSweep() {
        let rowCount = 0;
        outer: for (let y = tetrisBoard.length -1; y > 0; --y) {
            for (let x = 0; x < tetrisBoard[y].length; ++x) {
                if (tetrisBoard[y][x] === 0) {
                    continue outer;
                }
            }
            const row = tetrisBoard.splice(y, 1)[0].fill(0);
            tetrisBoard.unshift(row);
            ++y;
            rowCount++;
        }
        if (rowCount > 0) {
            tetrisScore += rowCount * 10 * rowCount;
            document.getElementById('tetris-score').textContent = tetrisScore;
            soundManager.play('clear');
        }
    }

    function playerDrop() {
        currentPiece.pos.y++;
        if (collide(tetrisBoard, currentPiece)) {
            currentPiece.pos.y--;
            merge(tetrisBoard, currentPiece);
            soundManager.play('drop');
            resetPiece();
            arenaSweep();
        }
        dropCounter = 0;
    }

    function updateTetris(time = 0) {
        if (currentGame !== 'tetris') return;

        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            playerDrop();
        }
        drawTetris();
        gameLoopId = requestAnimationFrame(updateTetris);
    }

    function handleTetrisInput(e) {
        if (currentGame !== 'tetris') return;
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        if (e.key === 'ArrowLeft') {
            currentPiece.pos.x--;
            if (collide(tetrisBoard, currentPiece)) {
                currentPiece.pos.x++;
            }
        } else if (e.key === 'ArrowRight') {
            currentPiece.pos.x++;
            if (collide(tetrisBoard, currentPiece)) {
                currentPiece.pos.x--;
            }
        } else if (e.key === 'ArrowDown') {
            playerDrop();
        } else if (e.key === 'ArrowUp') {
            playerRotate(1);
        }
    }
</script>
