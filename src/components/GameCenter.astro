---
---
<div id="game-center-container">
    <button id="joystick-btn" aria-label="Open Game Center" title="Play Games">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="joystick-icon">
            <rect x="2" y="6" width="20" height="12" rx="2"></rect>
            <path d="M6 12h4"></path>
            <path d="M8 10v4"></path>
            <line x1="15" y1="13" x2="15.01" y2="13"></line>
            <line x1="18" y1="11" x2="18.01" y2="11"></line>
        </svg>
    </button>

    <div id="game-modal" class="hidden">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">AI Arcade</h2>
                <button id="close-modal-btn" aria-label="Close">&times;</button>
            </div>

            <div id="game-menu">
                <button class="game-select-btn" data-game="tetris">
                    <span class="game-icon">üß©</span> Cluster Builder
                </button>
                <button class="game-select-btn" data-game="snake">
                    <span class="game-icon">üß¨</span> Data Stream
                </button>
                <button class="game-select-btn" data-game="tictactoe">
                    <span class="game-icon">üß†</span> Neural Nodes
                </button>
                 <button class="game-select-btn" data-game="breakout">
                    <span class="game-icon">üß±</span> Firewall Breaker
                </button>
                <button class="game-select-btn" data-game="sudoku">
                    <span class="game-icon">üî¢</span> Cipher Grid
                </button>
                <button class="game-select-btn" id="leaderboard-btn" style="margin-top: 1rem; border-color: #F59E0B; color: #F59E0B;">
                    <span class="game-icon">üèÜ</span> High Scores
                </button>
            </div>

            <div id="leaderboard-view" class="hidden">
                <h3>Top Scores</h3>
                <div id="leaderboard-content"></div>
                <button id="back-from-leaderboard-btn" class="menu-back-btn">‚Üê Back to Menu</button>
            </div>

            <div id="game-area" class="hidden">
                <div class="game-canvas-wrapper">
                    <canvas id="game-canvas" width="400" height="400"></canvas>
                    <div id="game-overlay" class="hidden">
                        <h3 id="game-overlay-title">Game Over</h3>
                        <p id="game-overlay-score">Score: 0</p>
                        <button id="game-restart-btn">Play Again</button>
                        <button id="game-quit-btn">Quit to Menu</button>
                    </div>
                    <!-- Sudoku Controls (Only Visible for Sudoku) -->
                    <div id="sudoku-controls" class="hidden">
                        <div class="sudoku-numpad">
                            <button data-num="1">1</button><button data-num="2">2</button><button data-num="3">3</button>
                            <button data-num="4">4</button><button data-num="5">5</button><button data-num="6">6</button>
                            <button data-num="7">7</button><button data-num="8">8</button><button data-num="9">9</button>
                            <button data-num="0" class="clear-btn">C</button>
                        </div>
                    </div>
                </div>

                <div class="game-controls-info">
                    <div class="score-display">Score: <span id="current-score">0</span></div>
                    <p id="controls-hint">Controls Info</p>
                    <button id="back-to-menu-btn" class="menu-back-btn">‚Üê Back to Menu</button>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    /* --- Styles --- */
    #joystick-btn {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        z-index: 9999; /* Ensure visibility */
        background-color: #1F2937;
        color: #60A5FA;
        border: 2px solid #60A5FA;
        border-radius: 50%;
        width: 4rem;
        height: 4rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 0 15px rgba(96, 165, 250, 0.5);
    }

    #joystick-btn:hover {
        background-color: #374151;
        transform: scale(1.1);
        box-shadow: 0 0 25px rgba(96, 165, 250, 0.8);
    }

    .joystick-icon {
        width: 2rem;
        height: 2rem;
    }

    #game-modal {
        position: fixed;
        inset: 0;
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Force hide hidden elements */
    .hidden { display: none !important; }

    #game-modal.hidden {
        display: none !important;
    }

    .modal-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(8px);
    }

    .modal-content {
        position: relative;
        background-color: #111827;
        border: 1px solid #374151;
        border-radius: 1rem;
        padding: 1.5rem;
        width: 95%;
        max-width: 500px;
        color: white;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        max-height: 90vh;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #374151;
        padding-bottom: 1rem;
    }

    #modal-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #60A5FA;
        margin: 0;
        text-shadow: 0 0 10px rgba(96, 165, 250, 0.3);
    }

    #close-modal-btn {
        background: none;
        border: none;
        color: #9CA3AF;
        font-size: 2rem;
        line-height: 1;
        cursor: pointer;
        transition: color 0.2s;
    }

    #close-modal-btn:hover { color: white; }

    #game-menu {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow-y: auto;
    }

    .game-select-btn {
        background-color: #1F2937;
        border: 1px solid #374151;
        padding: 1rem;
        border-radius: 0.75rem;
        color: white;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        transition: all 0.2s;
    }

    .game-select-btn:hover {
        background-color: #374151;
        border-color: #60A5FA;
        transform: translateY(-2px);
    }

    #game-area.hidden { display: none !important; }
    #leaderboard-view.hidden { display: none !important; }
    #game-menu.hidden { display: none !important; }

    .game-canvas-wrapper {
        position: relative;
        width: 100%;
        aspect-ratio: 1; /* Keep square mostly */
        background-color: #030712;
        border: 2px solid #374151;
        border-radius: 0.5rem;
        overflow: hidden;
        margin-bottom: 1rem;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #game-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        z-index: 10;
    }

    #game-overlay.hidden { display: none; }

    #game-overlay-title {
        font-size: 2rem;
        color: #F87171;
        margin: 0;
        font-weight: 800;
    }

    #game-overlay button {
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        border: none;
        font-weight: 600;
        cursor: pointer;
        width: 80%;
    }

    #game-restart-btn { background-color: #10B981; color: white; }
    #game-restart-btn:hover { background-color: #059669; }

    #game-quit-btn { background-color: #4B5563; color: white; margin-top: 0.5rem; }
    #game-quit-btn:hover { background-color: #374151; }

    .game-controls-info { text-align: center; }

    .score-display {
        font-size: 1.5rem;
        font-weight: bold;
        color: #60A5FA;
        margin-bottom: 0.5rem;
    }

    #controls-hint {
        color: #9CA3AF;
        font-size: 0.9rem;
        margin-bottom: 1rem;
    }

    .menu-back-btn {
        background: none;
        border: none;
        color: #9CA3AF;
        cursor: pointer;
        font-size: 0.9rem;
        text-decoration: underline;
    }
    .menu-back-btn:hover { color: white; }

    /* Leaderboard Styles */
    #leaderboard-view { text-align: center; }
    #leaderboard-view h3 { color: #F59E0B; margin-top: 0; }

    .leaderboard-game-section {
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #374151;
        padding-bottom: 0.5rem;
        text-align: left;
    }

    .leaderboard-game-title {
        font-weight: bold;
        color: #60A5FA;
        font-size: 0.9rem;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
    }

    .leaderboard-list {
        list-style: none;
        padding: 0;
        margin: 0;
        font-size: 0.9rem;
    }

    .leaderboard-list li {
        display: flex;
        justify-content: space-between;
        padding: 0.25rem 0;
        color: #D1D5DB;
        border-bottom: 1px dashed #374151;
    }
    .leaderboard-list li:last-child { border-bottom: none; }

    /* Sudoku Controls */
    #sudoku-controls {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(17, 24, 39, 0.9);
        padding: 0.5rem;
        display: flex;
        justify-content: center;
        border-top: 1px solid #374151;
    }
    #sudoku-controls.hidden { display: none !important; }

    .sudoku-numpad {
        display: flex;
        gap: 0.25rem;
    }

    .sudoku-numpad button {
        width: 2rem;
        height: 2rem;
        border-radius: 0.25rem;
        border: 1px solid #4B5563;
        background: #1F2937;
        color: white;
        font-weight: bold;
        cursor: pointer;
    }
    .sudoku-numpad button:hover { background: #374151; }
    .sudoku-numpad .clear-btn { color: #F87171; border-color: #F87171; }
</style>

<script>
    // --- UTILITIES ---
    class SoundManager {
        constructor() {
            this.ctx = null;
            this.enabled = true;
        }

        init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        }

        play(type) {
            if (!this.enabled) return;
            this.init();

            const now = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.connect(gain);
            gain.connect(this.ctx.destination);

            switch (type) {
                case 'pop': // Bubble Pop
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'move': // Soft blip
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
                case 'score': // High ping
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                    break;
                case 'gameover': // Deep wobble
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.exponentialRampToValueAtTime(20, now + 1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 1);
                    osc.start(now);
                    osc.stop(now + 1);
                    break;
                case 'hit': // Brick hit
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
            }
        }
    }

    class ScoreManager {
        constructor() {
            this.key = 'ai_arcade_scores_v2';
        }

        getScores() {
            try {
                return JSON.parse(localStorage.getItem(this.key)) || {
                    tetris: [], snake: [], tictactoe: 0, breakout: [], sudoku: []
                };
            } catch (e) {
                return { tetris: [], snake: [], tictactoe: 0, breakout: [], sudoku: [] };
            }
        }

        saveScore(game, score) {
            const scores = this.getScores();
            let isHigh = false;

            if (game === 'tictactoe') {
                if (score > (scores.tictactoe || 0)) {
                    scores.tictactoe = score;
                    isHigh = true;
                }
            } else {
                if (!scores[game]) scores[game] = [];
                scores[game].push({ score, date: new Date().toISOString() });
                scores[game].sort((a, b) => b.score - a.score);
                scores[game] = scores[game].slice(0, 5);
                isHigh = scores[game].some(s => s.score === score);
            }

            try {
                localStorage.setItem(this.key, JSON.stringify(scores));
            } catch (e) { console.error('Score save failed', e); }

            return isHigh;
        }
    }

    // --- GAME ENGINE ---
    document.addEventListener('DOMContentLoaded', () => {
        // Elements
        const joystickBtn = document.getElementById('joystick-btn');
        const modal = document.getElementById('game-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const gameMenu = document.getElementById('game-menu');
        const gameArea = document.getElementById('game-area');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const currentScoreEl = document.getElementById('current-score');
        const controlsHintEl = document.getElementById('controls-hint');
        const gameOverlay = document.getElementById('game-overlay');
        const gameOverlayTitle = document.getElementById('game-overlay-title');
        const gameOverlayScore = document.getElementById('game-overlay-score');
        const gameRestartBtn = document.getElementById('game-restart-btn');
        const gameQuitBtn = document.getElementById('game-quit-btn');
        const leaderboardBtn = document.getElementById('leaderboard-btn');
        const leaderboardView = document.getElementById('leaderboard-view');
        const leaderboardContent = document.getElementById('leaderboard-content');
        const backFromLeaderboardBtn = document.getElementById('back-from-leaderboard-btn');

        const sudokuControls = document.getElementById('sudoku-controls');
        const sudokuBtns = document.querySelectorAll('.sudoku-numpad button');

        // Utils
        const sound = new SoundManager();
        const scores = new ScoreManager();

        // State
        let currentGame = null;
        let gameLoopId = null;
        let lastTime = 0;
        let gameActive = false;

        // Game States
        let snakeState = {};
        let tetrisState = {};
        let tttState = {};
        let breakoutState = {};
        let sudokuState = {};

        // --- HANDLERS ---
        joystickBtn.addEventListener('click', () => {
            modal.classList.remove('hidden');
            showMenu();
        });

        closeModalBtn.addEventListener('click', () => {
            stopGame();
            modal.classList.add('hidden');
        });

        backToMenuBtn.addEventListener('click', () => {
            stopGame();
            showMenu();
        });

        gameQuitBtn.addEventListener('click', () => {
            stopGame();
            showMenu();
        });

        gameRestartBtn.addEventListener('click', () => {
            gameOverlay.classList.add('hidden');
            if (currentGame === 'snake') initSnake();
            else if (currentGame === 'tetris') initTetris();
            else if (currentGame === 'tictactoe') initTicTacToe();
            else if (currentGame === 'breakout') initBreakout();
            else if (currentGame === 'sudoku') initSudoku();
        });

        leaderboardBtn.addEventListener('click', showLeaderboard);
        backFromLeaderboardBtn.addEventListener('click', showMenu);

        document.querySelectorAll('.game-select-btn').forEach(btn => {
            if (btn.id === 'leaderboard-btn') return;
            btn.addEventListener('click', () => {
                const game = btn.dataset.game;
                startGame(game);
            });
        });

        // Input
        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;

            // Prevent scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }

            if (currentGame === 'snake') handleSnakeInput(e);
            if (currentGame === 'tetris') handleTetrisInput(e);
            if (currentGame === 'breakout') handleBreakoutInput(e);
        });

        document.addEventListener('keyup', (e) => {
             if (currentGame === 'breakout') handleBreakoutKeyUp(e);
        });

        // Changed to CLICK for better consistency than mousedown
        canvas.addEventListener('click', (e) => {
             if (!gameActive) return;
             if (currentGame === 'tictactoe') handleTicTacToeClick(e);
             if (currentGame === 'sudoku') handleSudokuClick(e);
        });

        // Sudoku Numpad
        sudokuBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                if (currentGame === 'sudoku') handleSudokuInput(btn.dataset.num);
            });
        });

        function showMenu() {
            gameMenu.classList.remove('hidden');
            gameArea.classList.add('hidden');
            leaderboardView.classList.add('hidden');
            sudokuControls.classList.add('hidden');
            document.getElementById('modal-title').textContent = "AI Arcade";
        }

        function showLeaderboard() {
            gameMenu.classList.add('hidden');
            leaderboardView.classList.remove('hidden');
            const data = scores.getScores();
            const fmtDate = (d) => new Date(d).toLocaleDateString();

            let html = '';
            const addSec = (title, list) => {
                html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">${title}</div><ul class="leaderboard-list">`;
                if (list.length) list.forEach(s => html += `<li><span>${fmtDate(s.date)}</span><span>${s.score}</span></li>`);
                else html += `<li>No scores yet</li>`;
                html += `</ul></div>`;
            };

            addSec("Cluster Builder", data.tetris || []);
            addSec("Data Stream", data.snake || []);
            addSec("Firewall Breaker", data.breakout || []);
            addSec("Cipher Grid (Solved)", data.sudoku || []);

            html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Neural Nodes (Streak)</div><ul class="leaderboard-list">`;
            html += `<li><span>Best Streak</span><span>${data.tictactoe || 0}</span></li>`;
            html += `</ul></div>`;

            leaderboardContent.innerHTML = html;
        }

        function startGame(game) {
            currentGame = game;
            gameMenu.classList.add('hidden');
            gameArea.classList.remove('hidden');
            gameOverlay.classList.add('hidden');
            sudokuControls.classList.add('hidden'); // Reset
            canvas.width = 400;
            canvas.height = 400;

            if (game === 'snake') initSnake();
            else if (game === 'tetris') initTetris();
            else if (game === 'tictactoe') initTicTacToe();
            else if (game === 'breakout') initBreakout();
            else if (game === 'sudoku') initSudoku();
        }

        function stopGame() {
            gameActive = false;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
        }

        function gameOver(score) {
            gameActive = false;
            sound.play('gameover');
            scores.saveScore(currentGame, score);

            gameOverlayTitle.textContent = "System Failure";
            if (currentGame === 'tictactoe' && score > 0) gameOverlayTitle.textContent = "Victory!";
            if (currentGame === 'sudoku' && score === 1) gameOverlayTitle.textContent = "Grid Decrypted!";

            gameOverlayScore.textContent = `Score: ${score}`;
            gameOverlay.classList.remove('hidden');
            sudokuControls.classList.add('hidden');
        }

        function loop(time) {
            if (!gameActive) return;
            const dt = time - lastTime;
            lastTime = time;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentGame === 'snake') updateSnake(dt);
            if (currentGame === 'tetris') updateTetris(dt);
            if (currentGame === 'breakout') updateBreakout(dt);
            if (currentGame === 'tictactoe') drawTicTacToe();
            if (currentGame === 'sudoku') drawSudoku();

            gameLoopId = requestAnimationFrame(loop);
        }

        // --- SNAKE: DATA STREAM ---
        function initSnake() {
            document.getElementById('modal-title').textContent = "Data Stream";
            controlsHintEl.textContent = "Arrow Keys to direct the stream";
            snakeState = {
                grid: 20,
                snake: [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}],
                dir: {x: 1, y: 0},
                nextDir: {x: 1, y: 0},
                food: null,
                score: 0,
                speed: 100, // ms per move
                timer: 0
            };
            spawnSnakeFood();
            gameActive = true;
            lastTime = performance.now();
            loop(lastTime);
        }

        function spawnSnakeFood() {
            const cols = canvas.width / snakeState.grid;
            const rows = canvas.height / snakeState.grid;
            snakeState.food = {
                x: Math.floor(Math.random() * cols),
                y: Math.floor(Math.random() * rows)
            };
        }

        function handleSnakeInput(e) {
            const { dir } = snakeState;
            switch(e.key) {
                case 'ArrowUp': if (dir.y === 0) snakeState.nextDir = {x: 0, y: -1}; break;
                case 'ArrowDown': if (dir.y === 0) snakeState.nextDir = {x: 0, y: 1}; break;
                case 'ArrowLeft': if (dir.x === 0) snakeState.nextDir = {x: -1, y: 0}; break;
                case 'ArrowRight': if (dir.x === 0) snakeState.nextDir = {x: 1, y: 0}; break;
            }
        }

        function updateSnake(dt) {
            snakeState.timer += dt;
            if (snakeState.timer < snakeState.speed) {
                drawSnake();
                return;
            }
            snakeState.timer = 0;

            snakeState.dir = snakeState.nextDir;
            const head = {
                x: snakeState.snake[0].x + snakeState.dir.x,
                y: snakeState.snake[0].y + snakeState.dir.y
            };

            const cols = canvas.width / snakeState.grid;
            const rows = canvas.height / snakeState.grid;

            if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows ||
                snakeState.snake.some(s => s.x === head.x && s.y === head.y)) {
                gameOver(snakeState.score);
                return;
            }

            snakeState.snake.unshift(head);
            sound.play('move');

            if (head.x === snakeState.food.x && head.y === snakeState.food.y) {
                snakeState.score += 10;
                sound.play('pop');
                currentScoreEl.textContent = snakeState.score;
                spawnSnakeFood();
                snakeState.speed = Math.max(50, snakeState.speed * 0.98);
            } else {
                snakeState.snake.pop();
            }

            drawSnake();
        }

        function drawSnake() {
            const g = snakeState.grid;
            const f = snakeState.food;

            ctx.shadowBlur = 15;
            ctx.shadowColor = '#F59E0B';
            ctx.fillStyle = '#F59E0B';
            ctx.beginPath();
            ctx.arc(f.x * g + g/2, f.y * g + g/2, g/2 - 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 10;
            ctx.shadowColor = '#60A5FA';

            snakeState.snake.forEach((seg, i) => {
                ctx.fillStyle = i === 0 ? '#FFFFFF' : '#60A5FA';
                ctx.beginPath();
                ctx.arc(seg.x * g + g/2, seg.y * g + g/2, g/2 - 1, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        // --- TETRIS: CLUSTER BUILDER ---
        // Padded to 4x4 or 3x3 for rotation consistency
        const tetrisShapes = [
            [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]], // I (4x4 center)
            [[1,1],[1,1]], // O (2x2 no rotate effect really)
            [[0,1,0],[1,1,1],[0,0,0]], // T (3x3)
            [[1,0,0],[1,1,1],[0,0,0]], // J (3x3)
            [[0,0,1],[1,1,1],[0,0,0]], // L (3x3)
            [[0,1,1],[1,1,0],[0,0,0]], // S (3x3)
            [[1,1,0],[0,1,1],[0,0,0]]  // Z (3x3)
        ];
        const tetrisColors = ['#06B6D4', '#F59E0B', '#8B5CF6', '#3B82F6', '#F97316', '#10B981', '#EF4444'];

        function initTetris() {
            document.getElementById('modal-title').textContent = "Cluster Builder";
            controlsHintEl.textContent = "Arrow Keys to Move/Rotate";
            tetrisState = {
                grid: 20,
                cols: 10,
                rows: 20,
                board: Array(20).fill().map(() => Array(10).fill(0)),
                score: 0,
                timer: 0,
                speed: 1000,
                piece: null
            };
            canvas.width = tetrisState.cols * tetrisState.grid;
            canvas.height = tetrisState.rows * tetrisState.grid;

            spawnTetrisPiece();
            currentScoreEl.textContent = 0;
            gameActive = true;
            lastTime = performance.now();
            loop(lastTime);
        }

        function spawnTetrisPiece() {
            const id = Math.floor(Math.random() * tetrisShapes.length);
            tetrisState.piece = {
                shape: tetrisShapes[id], // Use ref
                color: tetrisColors[id],
                x: 3,
                y: -1 // Start slightly higher
            };
            // Deep copy shape for rotation
            tetrisState.piece.shape = JSON.parse(JSON.stringify(tetrisShapes[id]));

            if (checkTetrisCollide()) {
                gameOver(tetrisState.score);
            }
        }

        function checkTetrisCollide(offX = 0, offY = 0, shape = null) {
            const s = shape || tetrisState.piece.shape;
            const px = tetrisState.piece.x + offX;
            const py = tetrisState.piece.y + offY;

            for (let y = 0; y < s.length; y++) {
                for (let x = 0; x < s[y].length; x++) {
                    if (s[y][x]) {
                        const bx = px + x;
                        const by = py + y;
                        if (bx < 0 || bx >= tetrisState.cols || by >= tetrisState.rows) return true;
                        // Ignore collision if above board (spawning)
                        if (by >= 0 && tetrisState.board[by][bx]) return true;
                    }
                }
            }
            return false;
        }

        function rotateTetrisPiece() {
            const piece = tetrisState.piece;
            // Matrix rotation
            const N = piece.shape.length;
            const newShape = piece.shape.map((row, i) =>
                row.map((val, j) => piece.shape[N - 1 - j][i])
            );

            if (!checkTetrisCollide(0, 0, newShape)) {
                piece.shape = newShape;
                sound.play('move');
            } else {
                // Wall kick attempt (simple)
                if (!checkTetrisCollide(-1, 0, newShape)) { piece.x--; piece.shape = newShape; return; }
                if (!checkTetrisCollide(1, 0, newShape)) { piece.x++; piece.shape = newShape; return; }
            }
        }

        function handleTetrisInput(e) {
            if (e.key === 'ArrowLeft') {
                if (!checkTetrisCollide(-1, 0)) { tetrisState.piece.x--; sound.play('move'); }
            }
            if (e.key === 'ArrowRight') {
                if (!checkTetrisCollide(1, 0)) { tetrisState.piece.x++; sound.play('move'); }
            }
            if (e.key === 'ArrowDown') {
                 if (!checkTetrisCollide(0, 1)) { tetrisState.piece.y++; }
            }
            if (e.key === 'ArrowUp') {
                rotateTetrisPiece();
            }
        }

        function updateTetris(dt) {
            tetrisState.timer += dt;
            if (tetrisState.timer > tetrisState.speed) {
                tetrisState.timer = 0;
                if (!checkTetrisCollide(0, 1)) {
                    tetrisState.piece.y++;
                } else {
                    // Lock
                    const p = tetrisState.piece;
                    p.shape.forEach((row, y) => {
                        row.forEach((val, x) => {
                            if (val) {
                                if (p.y + y >= 0) {
                                    tetrisState.board[p.y + y][p.x + x] = p.color;
                                }
                            }
                        });
                    });

                    // Clear lines
                    let lines = 0;
                    for (let y = tetrisState.rows - 1; y >= 0; y--) {
                        if (tetrisState.board[y].every(c => c !== 0)) {
                            tetrisState.board.splice(y, 1);
                            tetrisState.board.unshift(Array(tetrisState.cols).fill(0));
                            lines++;
                            y++;
                        }
                    }
                    if (lines > 0) {
                        tetrisState.score += lines * 100;
                        currentScoreEl.textContent = tetrisState.score;
                        sound.play('score');
                        tetrisState.speed *= 0.95;
                    } else {
                        sound.play('pop');
                    }
                    spawnTetrisPiece();
                }
            }
            drawTetris();
        }

        function drawTetris() {
            const g = tetrisState.grid;
            ctx.strokeStyle = '#1F2937';
            ctx.lineWidth = 1;
            for(let x=0; x<=canvas.width; x+=g) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }

            tetrisState.board.forEach((row, y) => {
                row.forEach((color, x) => {
                    if (color) {
                        drawBubble(x, y, color);
                    }
                });
            });

            if (tetrisState.piece) {
                tetrisState.piece.shape.forEach((row, y) => {
                    row.forEach((val, x) => {
                        if (val) {
                            drawBubble(tetrisState.piece.x + x, tetrisState.piece.y + y, tetrisState.piece.color, true);
                        }
                    });
                });
            }
        }

        function drawBubble(gx, gy, color, active=false) {
            const g = tetrisState.grid;
            const x = gx * g + g/2;
            const y = gy * g + g/2;
            const r = g/2 - 2;
            ctx.fillStyle = color;
            ctx.shadowBlur = active ? 10 : 0;
            ctx.shadowColor = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(x - r/3, y - r/3, r/4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // --- TIC-TAC-TOE: NEURAL NODES ---
        function initTicTacToe() {
            document.getElementById('modal-title').textContent = "Neural Nodes";
            controlsHintEl.textContent = "Click a Node to Capture";
            tttState = {
                board: Array(9).fill(null),
                player: 'X',
                streak: 0,
                winner: null,
                lock: false // Input lock for cpu turn
            };
            gameActive = true;
            currentScoreEl.textContent = 0;
            drawTicTacToe();
        }

        function handleTicTacToeClick(e) {
            if (tttState.winner || tttState.player !== 'X' || tttState.lock) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cellW = canvas.width / 3;
            const cellH = canvas.height / 3;

            const col = Math.floor(x / cellW);
            const row = Math.floor(y / cellH);
            const idx = row * 3 + col;

            if (idx >= 0 && idx < 9 && tttState.board[idx] === null) {
                tttState.board[idx] = 'X';
                sound.play('pop');
                drawTicTacToe();
                checkTTTWin();

                if (!tttState.winner) {
                    tttState.player = 'O';
                    tttState.lock = true;
                    setTimeout(cpuMove, 600);
                }
            }
        }

        function cpuMove() {
            if (tttState.winner || !gameActive) return;
            const empty = tttState.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
            if (empty.length > 0) {
                const pick = empty[Math.floor(Math.random() * empty.length)];
                tttState.board[pick] = 'O';
                sound.play('move');
                checkTTTWin();
                if (!tttState.winner) {
                    tttState.player = 'X';
                }
                drawTicTacToe();
            }
            tttState.lock = false;
        }

        function checkTTTWin() {
            const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            for (let w of wins) {
                const [a,b,c] = w;
                if (tttState.board[a] && tttState.board[a] === tttState.board[b] && tttState.board[a] === tttState.board[c]) {
                    tttState.winner = tttState.board[a];
                    endTTT(tttState.winner);
                    return;
                }
            }
            if (!tttState.board.includes(null)) {
                tttState.winner = 'draw';
                endTTT('draw');
            }
        }

        function endTTT(winner) {
            if (winner === 'X') {
                tttState.streak++;
                currentScoreEl.textContent = tttState.streak;
                sound.play('score');
                setTimeout(() => {
                    if(!gameActive) return;
                    tttState.board.fill(null);
                    tttState.winner = null;
                    tttState.player = 'X';
                    tttState.lock = false;
                    drawTicTacToe();
                }, 1000);
            } else {
                gameActive = false;
                gameOver(tttState.streak);
            }
        }

        function drawTicTacToe() {
            const w = canvas.width / 3;
            const h = canvas.height / 3;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Grid Lines
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(w, 0); ctx.lineTo(w, canvas.height);
            ctx.moveTo(w*2, 0); ctx.lineTo(w*2, canvas.height);
            ctx.moveTo(0, h); ctx.lineTo(canvas.width, h);
            ctx.moveTo(0, h*2); ctx.lineTo(canvas.width, h*2);
            ctx.stroke();

            // Draw Nodes
            tttState.board.forEach((cell, i) => {
                if (!cell) return;
                const col = i % 3;
                const row = Math.floor(i / 3);
                const cx = col * w + w/2;
                const cy = row * h + h/2;
                ctx.shadowBlur = 20;
                if (cell === 'X') {
                    ctx.fillStyle = '#3B82F6';
                    ctx.shadowColor = '#3B82F6';
                } else {
                    ctx.fillStyle = '#EF4444';
                    ctx.shadowColor = '#EF4444';
                }
                ctx.beginPath();
                ctx.arc(cx, cy, w/3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        // --- BREAKOUT: FIREWALL BREAKER ---
        function initBreakout() {
            document.getElementById('modal-title').textContent = "Firewall Breaker";
            controlsHintEl.textContent = "Arrow Keys to move";
            breakoutState = {
                paddle: { x: 150, y: 380, w: 80, h: 10, dx: 0 },
                ball: { x: 200, y: 300, r: 6, dx: 3, dy: -3 },
                bricks: [],
                score: 0,
                lives: 3
            };

            // Create bricks
            for(let c=0; c<8; c++) {
                for(let r=0; r<6; r++) {
                    breakoutState.bricks.push({ x: c*50, y: r*25 + 30, status: 1 });
                }
            }

            currentScoreEl.textContent = 0;
            gameActive = true;
            lastTime = performance.now();
            loop(lastTime);
        }

        function handleBreakoutInput(e) {
            if(e.key === 'ArrowRight') breakoutState.paddle.dx = 6;
            if(e.key === 'ArrowLeft') breakoutState.paddle.dx = -6;
        }

        function handleBreakoutKeyUp(e) {
            if(e.key === 'ArrowRight' || e.key === 'ArrowLeft') breakoutState.paddle.dx = 0;
        }

        function updateBreakout(dt) {
            const b = breakoutState;

            // Move Paddle
            b.paddle.x += b.paddle.dx;
            if(b.paddle.x < 0) b.paddle.x = 0;
            if(b.paddle.x + b.paddle.w > canvas.width) b.paddle.x = canvas.width - b.paddle.w;

            // Move Ball
            b.ball.x += b.ball.dx;
            b.ball.y += b.ball.dy;

            // Walls
            if(b.ball.x + b.ball.r > canvas.width || b.ball.x - b.ball.r < 0) { b.ball.dx = -b.ball.dx; sound.play('move'); }
            if(b.ball.y - b.ball.r < 0) { b.ball.dy = -b.ball.dy; sound.play('move'); }

            // Paddle Collision
            if(b.ball.y + b.ball.r >= b.paddle.y && b.ball.x >= b.paddle.x && b.ball.x <= b.paddle.x + b.paddle.w) {
                b.ball.dy = -Math.abs(b.ball.dy); // Force up
                sound.play('move');
            }

            // Floor (Death)
            if(b.ball.y + b.ball.r > canvas.height) {
                b.lives--;
                sound.play('gameover');
                if(b.lives === 0) {
                    gameOver(b.score);
                } else {
                    b.ball.x = 200; b.ball.y = 300; b.ball.dy = -3;
                }
            }

            // Bricks
            b.bricks.forEach(brick => {
                if(brick.status === 1) {
                    if(b.ball.x > brick.x && b.ball.x < brick.x + 50 && b.ball.y > brick.y && b.ball.y < brick.y + 25) {
                        b.ball.dy = -b.ball.dy;
                        brick.status = 0;
                        b.score += 10;
                        sound.play('hit');
                        currentScoreEl.textContent = b.score;
                        if(b.score === b.bricks.length * 10) gameOver(b.score); // Win
                    }
                }
            });

            drawBreakout();
        }

        function drawBreakout() {
            // Draw Bricks
            breakoutState.bricks.forEach(brick => {
                if(brick.status === 1) {
                    ctx.fillStyle = '#60A5FA';
                    ctx.fillRect(brick.x + 2, brick.y + 2, 46, 21);
                    ctx.shadowBlur = 5; ctx.shadowColor = '#60A5FA';
                }
            });
            ctx.shadowBlur = 0;

            // Paddle
            ctx.fillStyle = '#10B981';
            ctx.fillRect(breakoutState.paddle.x, breakoutState.paddle.y, breakoutState.paddle.w, breakoutState.paddle.h);

            // Ball
            ctx.beginPath();
            ctx.arc(breakoutState.ball.x, breakoutState.ball.y, breakoutState.ball.r, 0, Math.PI*2);
            ctx.fillStyle = '#FFFFFF';
            ctx.fill();
        }

        // --- SUDOKU: CIPHER GRID ---
        // Simple solved board + mask
        const solvedSudoku = "534678912672195348198342567859761423426853791713924856961537284287419635345286179";

        function initSudoku() {
             document.getElementById('modal-title').textContent = "Cipher Grid";
             controlsHintEl.textContent = "Select Cell -> Type Number";
             sudokuControls.classList.remove('hidden');

             sudokuState = {
                 grid: Array(81).fill(0),
                 fixed: Array(81).fill(false),
                 selected: -1,
                 solved: solvedSudoku
             };

             // Create puzzle (mask ~40%)
             for(let i=0; i<81; i++) {
                 if(Math.random() > 0.5) {
                     sudokuState.grid[i] = parseInt(solvedSudoku[i]);
                     sudokuState.fixed[i] = true;
                 } else {
                     sudokuState.grid[i] = 0;
                 }
             }

             gameActive = true;
             currentScoreEl.textContent = 0;
             drawSudoku();
        }

        function handleSudokuClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const cellS = canvas.width / 9;

            const col = Math.floor(x / cellS);
            const row = Math.floor(y / cellS);
            const idx = row * 9 + col;

            if(idx >= 0 && idx < 81) {
                sudokuState.selected = idx;
                drawSudoku();
            }
        }

        function handleSudokuInput(numStr) {
            if(sudokuState.selected === -1) return;
            if(sudokuState.fixed[sudokuState.selected]) return;

            const num = parseInt(numStr);
            sudokuState.grid[sudokuState.selected] = num;
            sound.play('pop');
            drawSudoku();

            // Check win?
            if(sudokuState.grid.join('') === sudokuState.solved) {
                 sound.play('score');
                 gameOver(1); // 1 = Win
            }
        }

        function drawSudoku() {
            const s = canvas.width / 9;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            // Cells
            for(let i=0; i<81; i++) {
                const col = i % 9;
                const row = Math.floor(i / 9);
                const x = col * s;
                const y = row * s;

                // Selection
                if(sudokuState.selected === i) {
                    ctx.fillStyle = 'rgba(96, 165, 250, 0.2)';
                    ctx.fillRect(x,y,s,s);
                }

                // Text
                const val = sudokuState.grid[i];
                if(val !== 0) {
                    ctx.fillStyle = sudokuState.fixed[i] ? '#9CA3AF' : '#60A5FA';
                    ctx.font = '24px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(val, x + s/2, y + s/2);
                }
            }

            // Grid Lines
            ctx.strokeStyle = '#374151';
            for(let i=0; i<=9; i++) {
                ctx.lineWidth = (i % 3 === 0) ? 3 : 1;
                ctx.beginPath();
                ctx.moveTo(i*s, 0); ctx.lineTo(i*s, canvas.height);
                ctx.moveTo(0, i*s); ctx.lineTo(canvas.width, i*s);
                ctx.stroke();
            }
        }
    });
</script>
