---
---
<div id="game-center-container">
    <button id="joystick-btn" aria-label="Open Game Center" title="Play Games">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="joystick-icon">
            <rect x="2" y="6" width="20" height="12" rx="2"></rect>
            <path d="M6 12h4"></path>
            <path d="M8 10v4"></path>
            <line x1="15" y1="13" x2="15.01" y2="13"></line>
            <line x1="18" y1="11" x2="18.01" y2="11"></line>
        </svg>
    </button>

    <div id="game-modal" class="hidden">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Arcade Center</h2>
                <button id="close-modal-btn" aria-label="Close">&times;</button>
            </div>

            <div id="game-menu">
                <button class="game-select-btn" data-game="tetris">
                    <span class="game-icon">üß±</span> Tetris
                </button>
                <button class="game-select-btn" data-game="snake">
                    <span class="game-icon">üêç</span> Snake
                </button>
                <button class="game-select-btn" data-game="tictactoe">
                    <span class="game-icon">‚ùå</span> Tic-Tac-Toe
                </button>
            </div>

            <div id="game-area" class="hidden">
                <!-- Tetris -->
                <div id="tetris-container" class="game-container hidden">
                    <canvas id="tetris-canvas" width="240" height="400"></canvas>
                    <div class="game-info">
                        <div class="score-display">Score: <span id="tetris-score">0</span></div>
                        <p class="controls-hint">‚Üê ‚Üí Move, ‚Üë Rotate, ‚Üì Drop</p>
                        <button class="restart-btn" id="restart-tetris">Restart Game</button>
                    </div>
                </div>

                <!-- Snake -->
                <div id="snake-container" class="game-container hidden">
                    <canvas id="snake-canvas" width="400" height="400"></canvas>
                    <div class="game-info">
                        <div class="score-display">Score: <span id="snake-score">0</span></div>
                        <p class="controls-hint">Arrow Keys to Move</p>
                        <button class="restart-btn" id="restart-snake">Restart Game</button>
                    </div>
                </div>

                <!-- Tic-Tac-Toe -->
                <div id="tictactoe-container" class="game-container hidden">
                    <div id="tictactoe-board"></div>
                    <div class="game-info">
                        <div id="tictactoe-status" class="status-msg">Player X Turn</div>
                        <button class="restart-btn" id="restart-tictactoe">Restart Game</button>
                    </div>
                </div>

                <button id="back-to-menu-btn">‚Üê Back to Menu</button>
            </div>
        </div>
    </div>
</div>

<style>
    #joystick-btn {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 40;
        background-color: #374151;
        color: white;
        border: 1px solid #4B5563;
        border-radius: 50%;
        width: 3rem;
        height: 3rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    #joystick-btn:hover {
        background-color: #4B5563;
        transform: scale(1.1);
    }

    .joystick-icon {
        width: 1.5rem;
        height: 1.5rem;
    }

    #game-modal {
        position: fixed;
        inset: 0;
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #game-modal.hidden {
        display: none;
    }

    .modal-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(4px);
    }

    .modal-content {
        position: relative;
        background-color: #1F2937;
        border: 1px solid #374151;
        border-radius: 0.75rem;
        padding: 1.5rem;
        width: 90%;
        max-width: 500px;
        color: white;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        max-height: 90vh;
        overflow-y: auto;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #374151;
        padding-bottom: 1rem;
    }

    #modal-title {
        font-size: 1.5rem;
        font-weight: bold;
        color: #F3F4F6;
        margin: 0;
    }

    #close-modal-btn {
        background: none;
        border: none;
        color: #9CA3AF;
        font-size: 2rem;
        line-height: 1;
        cursor: pointer;
        padding: 0;
    }

    #close-modal-btn:hover {
        color: white;
    }

    #game-menu {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .game-select-btn {
        background-color: #374151;
        border: 1px solid #4B5563;
        padding: 1rem;
        border-radius: 0.5rem;
        color: white;
        font-size: 1.25rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        transition: all 0.2s;
    }

    .game-select-btn:hover {
        background-color: #4B5563;
        transform: translateY(-2px);
    }

    .game-icon {
        font-size: 1.5rem;
    }

    #game-area.hidden {
        display: none;
    }

    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
    }

    .game-container.hidden {
        display: none;
    }

    canvas {
        background-color: #111827;
        border: 2px solid #4B5563;
        border-radius: 0.25rem;
        max-width: 100%;
    }

    .game-info {
        text-align: center;
        width: 100%;
    }

    .score-display {
        font-size: 1.25rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: #60A5FA;
    }

    .controls-hint {
        color: #9CA3AF;
        font-size: 0.875rem;
        margin-bottom: 1rem;
    }

    .restart-btn {
        background-color: #DC2626;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-weight: 600;
        transition: background-color 0.2s;
    }

    .restart-btn:hover {
        background-color: #B91C1C;
    }

    #back-to-menu-btn {
        margin-top: 1.5rem;
        background: none;
        border: none;
        color: #9CA3AF;
        cursor: pointer;
        font-size: 0.875rem;
        text-decoration: underline;
        width: 100%;
    }

    #back-to-menu-btn:hover {
        color: white;
    }

    /* Tic-Tac-Toe Specific */
    #tictactoe-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        background-color: #4B5563;
        padding: 0.5rem;
        border-radius: 0.5rem;
    }

    .ttt-cell {
        width: 4rem;
        height: 4rem;
        background-color: #1F2937;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.5rem;
        font-weight: bold;
        color: white;
        cursor: pointer;
        user-select: none;
    }

    .ttt-cell:hover {
        background-color: #374151;
    }

    .ttt-cell.x { color: #60A5FA; }
    .ttt-cell.o { color: #F87171; }

    .status-msg {
        font-size: 1.25rem;
        margin-bottom: 1rem;
        font-weight: bold;
    }

</style>

<script>
    // --- State Management ---
    let currentGame = null;
    let gameLoopId = null;

    // --- DOM Elements ---
    const joystickBtn = document.getElementById('joystick-btn');
    const modal = document.getElementById('game-modal');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const gameMenu = document.getElementById('game-menu');
    const gameArea = document.getElementById('game-area');
    const backToMenuBtn = document.getElementById('back-to-menu-btn');
    const gameButtons = document.querySelectorAll('.game-select-btn');

    // --- Event Listeners ---
    joystickBtn.addEventListener('click', openModal);
    closeModalBtn.addEventListener('click', closeModal);
    backToMenuBtn.addEventListener('click', showMenu);

    gameButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            const gameName = btn.dataset.game;
            startGame(gameName);
        });
    });

    document.getElementById('restart-tetris').addEventListener('click', () => initTetris());
    document.getElementById('restart-snake').addEventListener('click', () => initSnake());
    document.getElementById('restart-tictactoe').addEventListener('click', () => initTicTacToe());

    // --- Modal Logic ---
    function openModal() {
        modal.classList.remove('hidden');
        showMenu();
    }

    function closeModal() {
        modal.classList.add('hidden');
        stopGameLoop();
        currentGame = null;
    }

    function showMenu() {
        stopGameLoop();
        gameMenu.classList.remove('hidden');
        gameArea.classList.add('hidden');
        document.querySelectorAll('.game-container').forEach(el => el.classList.add('hidden'));
        document.getElementById('modal-title').textContent = "Arcade Center";
    }

    function startGame(gameName) {
        gameMenu.classList.add('hidden');
        gameArea.classList.remove('hidden');
        currentGame = gameName;

        document.querySelectorAll('.game-container').forEach(el => el.classList.add('hidden'));

        if (gameName === 'tetris') {
            document.getElementById('tetris-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Tetris";
            initTetris();
        } else if (gameName === 'snake') {
            document.getElementById('snake-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Snake";
            initSnake();
        } else if (gameName === 'tictactoe') {
            document.getElementById('tictactoe-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Tic-Tac-Toe";
            initTicTacToe();
        }
    }

    function stopGameLoop() {
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
        }
        if (snakeInterval) {
            clearInterval(snakeInterval);
            snakeInterval = null;
        }
    }

    // ==========================================
    // TIC-TAC-TOE
    // ==========================================
    let tttBoard = Array(9).fill(null);
    let tttPlayer = 'X';
    let tttActive = true;

    function initTicTacToe() {
        tttBoard = Array(9).fill(null);
        tttPlayer = 'X';
        tttActive = true;
        updateTicTacToeUI();
    }

    function updateTicTacToeUI() {
        const boardEl = document.getElementById('tictactoe-board');
        boardEl.innerHTML = '';
        const statusEl = document.getElementById('tictactoe-status');

        tttBoard.forEach((cell, index) => {
            const cellEl = document.createElement('div');
            cellEl.classList.add('ttt-cell');
            if (cell) cellEl.classList.add(cell.toLowerCase());
            cellEl.textContent = cell || '';
            cellEl.addEventListener('click', () => handleTicTacToeClick(index));
            boardEl.appendChild(cellEl);
        });

        if (checkTicTacToeWin()) {
            statusEl.textContent = `Player ${tttPlayer === 'X' ? 'O' : 'X'} Wins!`;
            tttActive = false;
        } else if (!tttBoard.includes(null)) {
            statusEl.textContent = "It's a Draw!";
            tttActive = false;
        } else {
            statusEl.textContent = `Player ${tttPlayer}'s Turn`;
        }
    }

    function handleTicTacToeClick(index) {
        if (!tttActive || tttBoard[index]) return;
        tttBoard[index] = tttPlayer;
        if (!checkTicTacToeWin()) {
            tttPlayer = tttPlayer === 'X' ? 'O' : 'X';
        }
        updateTicTacToeUI();
    }

    function checkTicTacToeWin() {
        const wins = [
            [0,1,2], [3,4,5], [6,7,8], // Rows
            [0,3,6], [1,4,7], [2,5,8], // Cols
            [0,4,8], [2,4,6]           // Diags
        ];
        return wins.some(combo => {
            const [a, b, c] = combo;
            return tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c];
        });
    }

    // ==========================================
    // SNAKE
    // ==========================================
    let snakeCanvas, snakeCtx;
    let snake = [];
    let snakeFood = {};
    let snakeDir = 'right';
    let snakeNextDir = 'right';
    let snakeScore = 0;
    let snakeInterval = null;
    const snakeGrid = 20;

    function initSnake() {
        stopGameLoop();
        snakeCanvas = document.getElementById('snake-canvas');
        snakeCtx = snakeCanvas.getContext('2d');

        snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
        snakeDir = 'right';
        snakeNextDir = 'right';
        snakeScore = 0;
        document.getElementById('snake-score').textContent = snakeScore;
        placeSnakeFood();

        // Use SetInterval for Snake speed control
        snakeInterval = setInterval(updateSnake, 100);

        document.addEventListener('keydown', handleSnakeInput);
    }

    function handleSnakeInput(e) {
        if (currentGame !== 'snake') return;

        // Prevent default scrolling for arrow keys
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        switch(e.key) {
            case 'ArrowUp': if (snakeDir !== 'down') snakeNextDir = 'up'; break;
            case 'ArrowDown': if (snakeDir !== 'up') snakeNextDir = 'down'; break;
            case 'ArrowLeft': if (snakeDir !== 'right') snakeNextDir = 'left'; break;
            case 'ArrowRight': if (snakeDir !== 'left') snakeNextDir = 'right'; break;
        }
    }

    function placeSnakeFood() {
        snakeFood = {
            x: Math.floor(Math.random() * (snakeCanvas.width / snakeGrid)),
            y: Math.floor(Math.random() * (snakeCanvas.height / snakeGrid))
        };
        // Ensure food doesn't spawn on snake
        if (snake.some(seg => seg.x === snakeFood.x && seg.y === snakeFood.y)) {
            placeSnakeFood();
        }
    }

    function updateSnake() {
        if (currentGame !== 'snake') return;

        snakeDir = snakeNextDir;
        const head = { ...snake[0] };

        if (snakeDir === 'right') head.x++;
        if (snakeDir === 'left') head.x--;
        if (snakeDir === 'up') head.y--;
        if (snakeDir === 'down') head.y++;

        // Wrap around? Or Game Over? Classic snake is game over on wall.
        // Let's do Game Over on wall for challenge.
        if (head.x < 0 || head.x >= snakeCanvas.width / snakeGrid ||
            head.y < 0 || head.y >= snakeCanvas.height / snakeGrid ||
            snake.some(seg => seg.x === head.x && seg.y === head.y)) {
            gameOverSnake();
            return;
        }

        snake.unshift(head);

        if (head.x === snakeFood.x && head.y === snakeFood.y) {
            snakeScore += 10;
            document.getElementById('snake-score').textContent = snakeScore;
            placeSnakeFood();
        } else {
            snake.pop();
        }

        drawSnake();
    }

    function drawSnake() {
        // Clear
        snakeCtx.fillStyle = '#111827';
        snakeCtx.fillRect(0, 0, snakeCanvas.width, snakeCanvas.height);

        // Food
        snakeCtx.fillStyle = '#EF4444';
        snakeCtx.fillRect(snakeFood.x * snakeGrid, snakeFood.y * snakeGrid, snakeGrid - 2, snakeGrid - 2);

        // Snake
        snakeCtx.fillStyle = '#10B981';
        snake.forEach(seg => {
            snakeCtx.fillRect(seg.x * snakeGrid, seg.y * snakeGrid, snakeGrid - 2, snakeGrid - 2);
        });
    }

    function gameOverSnake() {
        stopGameLoop();
        snakeCtx.fillStyle = 'white';
        snakeCtx.font = '30px sans-serif';
        snakeCtx.textAlign = 'center';
        snakeCtx.fillText("Game Over", snakeCanvas.width / 2, snakeCanvas.height / 2);
    }

    // ==========================================
    // TETRIS
    // ==========================================
    const tetrisCols = 10;
    const tetrisRows = 20;
    const blockSize = 24;
    let tetrisCanvas, tetrisCtx;
    let tetrisBoard = [];
    let tetrisScore = 0;
    let currentPiece = null;
    let lastTime = 0;
    let dropCounter = 0;
    let dropInterval = 1000;

    const pieces = 'ILJOTSZ';
    const shapes = {
        'I': [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
        'L': [[0,0,1], [1,1,1], [0,0,0]],
        'J': [[1,0,0], [1,1,1], [0,0,0]],
        'O': [[1,1], [1,1]],
        'Z': [[1,1,0], [0,1,1], [0,0,0]],
        'S': [[0,1,1], [1,1,0], [0,0,0]],
        'T': [[0,1,0], [1,1,1], [0,0,0]]
    };
    const colors = {
        'I': '#06B6D4', 'O': '#F59E0B', 'T': '#8B5CF6',
        'S': '#10B981', 'Z': '#EF4444', 'J': '#3B82F6', 'L': '#F97316'
    };

    function initTetris() {
        stopGameLoop();
        tetrisCanvas = document.getElementById('tetris-canvas');
        tetrisCtx = tetrisCanvas.getContext('2d');
        tetrisCtx.scale(1, 1); // Reset scale if needed?

        tetrisBoard = Array(tetrisRows).fill().map(() => Array(tetrisCols).fill(0));
        tetrisScore = 0;
        document.getElementById('tetris-score').textContent = tetrisScore;

        resetPiece();
        dropCounter = 0;
        lastTime = 0;

        gameLoopId = requestAnimationFrame(updateTetris);
        document.addEventListener('keydown', handleTetrisInput);
    }

    function resetPiece() {
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        currentPiece = {
            matrix: shapes[type],
            pos: {x: Math.floor(tetrisCols / 2) - 1, y: 0},
            type: type
        };
        if (collide(tetrisBoard, currentPiece)) {
            // Game Over
            tetrisBoard.forEach(row => row.fill(0)); // Reset board for visual effect
            tetrisScore = 0; // Or handle game over properly
            // For now, just reset
            resetPiece();
        }
    }

    function collide(board, piece) {
        const m = piece.matrix;
        const o = piece.pos;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 &&
                   (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    // Logic to determine color: if matrix is the board, value is string color type
                    // If matrix is piece, use piece type
                    const color = typeof value === 'string' ? colors[value] : colors[currentPiece.type];
                    tetrisCtx.fillStyle = color;
                    tetrisCtx.fillRect((x + offset.x) * blockSize, (y + offset.y) * blockSize, blockSize - 1, blockSize - 1);
                }
            });
        });
    }

    function drawTetris() {
        tetrisCtx.fillStyle = '#111827';
        tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);

        drawMatrix(tetrisBoard, {x: 0, y: 0});
        drawMatrix(currentPiece.matrix, currentPiece.pos);
    }

    function merge(board, piece) {
        piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    board[y + piece.pos.y][x + piece.pos.x] = piece.type;
                }
            });
        });
    }

    function rotate(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        if (dir > 0) matrix.forEach(row => row.reverse());
        else matrix.reverse();
    }

    function playerRotate(dir) {
        const pos = currentPiece.pos.x;
        let offset = 1;
        rotate(currentPiece.matrix, dir);
        while (collide(tetrisBoard, currentPiece)) {
            currentPiece.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > currentPiece.matrix[0].length) {
                rotate(currentPiece.matrix, -dir);
                currentPiece.pos.x = pos;
                return;
            }
        }
    }

    function arenaSweep() {
        let rowCount = 0;
        outer: for (let y = tetrisBoard.length -1; y > 0; --y) {
            for (let x = 0; x < tetrisBoard[y].length; ++x) {
                if (tetrisBoard[y][x] === 0) {
                    continue outer;
                }
            }
            const row = tetrisBoard.splice(y, 1)[0].fill(0);
            tetrisBoard.unshift(row);
            ++y;
            rowCount++;
        }
        if (rowCount > 0) {
            tetrisScore += rowCount * 10 * rowCount;
            document.getElementById('tetris-score').textContent = tetrisScore;
        }
    }

    function playerDrop() {
        currentPiece.pos.y++;
        if (collide(tetrisBoard, currentPiece)) {
            currentPiece.pos.y--;
            merge(tetrisBoard, currentPiece);
            resetPiece();
            arenaSweep();
        }
        dropCounter = 0;
    }

    function updateTetris(time = 0) {
        if (currentGame !== 'tetris') return;

        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            playerDrop();
        }
        drawTetris();
        gameLoopId = requestAnimationFrame(updateTetris);
    }

    function handleTetrisInput(e) {
        if (currentGame !== 'tetris') return;
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        if (e.key === 'ArrowLeft') {
            currentPiece.pos.x--;
            if (collide(tetrisBoard, currentPiece)) {
                currentPiece.pos.x++;
            }
        } else if (e.key === 'ArrowRight') {
            currentPiece.pos.x++;
            if (collide(tetrisBoard, currentPiece)) {
                currentPiece.pos.x--;
            }
        } else if (e.key === 'ArrowDown') {
            playerDrop();
        } else if (e.key === 'ArrowUp') {
            playerRotate(1);
        }
    }
</script>
