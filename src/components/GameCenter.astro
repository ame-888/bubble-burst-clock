---
---
<div id="game-center-container">
    <button id="joystick-btn" aria-label="Open Game Center" title="Play Games">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="joystick-icon">
            <rect x="2" y="6" width="20" height="12" rx="2"></rect>
            <path d="M6 12h4"></path>
            <path d="M8 10v4"></path>
            <line x1="15" y1="13" x2="15.01" y2="13"></line>
            <line x1="18" y1="11" x2="18.01" y2="11"></line>
        </svg>
    </button>

    <div id="game-modal" class="hidden">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Arcade Center</h2>
                <div class="header-controls">
                    <button id="sound-toggle-btn" aria-label="Toggle Sound" title="Toggle Sound">
                        üîä
                    </button>
                    <button id="close-modal-btn" aria-label="Close">&times;</button>
                </div>
            </div>

            <div id="game-menu">
                <button class="game-select-btn" data-game="tetris">
                    <span class="game-icon">üß±</span> Tetris
                </button>
                <button class="game-select-btn" data-game="snake">
                    <span class="game-icon">üêç</span> Snake
                </button>
                <button class="game-select-btn" data-game="tictactoe">
                    <span class="game-icon">‚ùå</span> Tic-Tac-Toe
                </button>
            </div>

            <div id="game-area" class="hidden">
                <!-- Tetris -->
                <div id="tetris-container" class="game-container hidden">
                    <div class="canvas-wrapper">
                        <canvas id="tetris-canvas" width="240" height="400"></canvas>
                        <div id="tetris-overlay" class="game-overlay hidden">
                            <h3 class="overlay-title">Game Over</h3>
                            <p class="overlay-score">Score: <span id="tetris-final-score">0</span></p>
                            <button class="overlay-btn" id="tetris-retry">Try Again</button>
                        </div>
                    </div>
                    <div class="game-info">
                        <div class="score-display">Score: <span id="tetris-score">0</span></div>
                        <p class="controls-hint">‚Üê ‚Üí Move, ‚Üë Rotate, ‚Üì Drop</p>
                        <button class="restart-btn" id="restart-tetris">Restart</button>
                    </div>
                </div>

                <!-- Snake -->
                <div id="snake-container" class="game-container hidden">
                    <div class="canvas-wrapper">
                        <canvas id="snake-canvas" width="400" height="400"></canvas>
                        <div id="snake-overlay" class="game-overlay hidden">
                            <h3 class="overlay-title">Game Over</h3>
                            <p class="overlay-score">Score: <span id="snake-final-score">0</span></p>
                            <button class="overlay-btn" id="snake-retry">Try Again</button>
                        </div>
                    </div>
                    <div class="game-info">
                        <div class="score-display">Score: <span id="snake-score">0</span></div>
                        <p class="controls-hint">Arrow Keys to Move</p>
                        <button class="restart-btn" id="restart-snake">Restart</button>
                    </div>
                </div>

                <!-- Tic-Tac-Toe -->
                <div id="tictactoe-container" class="game-container hidden">
                    <div id="tictactoe-board"></div>
                    <div class="game-info">
                        <div id="tictactoe-status" class="status-msg">Player X Turn</div>
                        <button class="restart-btn" id="restart-tictactoe">Restart</button>
                    </div>
                </div>

                <button id="back-to-menu-btn">‚Üê Back to Menu</button>
            </div>
        </div>
    </div>
</div>

<style>
    /* UI Styles */
    #joystick-btn {
        position: fixed;
        top: 1rem;
        left: 1rem;
        z-index: 40;
        background-color: #374151;
        color: white;
        border: 2px solid #4B5563;
        border-radius: 50%;
        width: 3.5rem;
        height: 3.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.1), inset 0 2px 4px rgba(255,255,255,0.1);
    }

    #joystick-btn:hover {
        background-color: #4B5563;
        transform: scale(1.1) rotate(-10deg);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        color: #FCD34D;
        border-color: #FCD34D;
    }

    .joystick-icon {
        width: 1.75rem;
        height: 1.75rem;
    }

    #game-modal {
        position: fixed;
        inset: 0;
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: 'Courier New', Courier, monospace; /* Retro font */
    }

    #game-modal.hidden {
        display: none;
    }

    .modal-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(17, 24, 39, 0.9);
        backdrop-filter: blur(5px);
    }

    .modal-content {
        position: relative;
        background-color: #1F2937;
        border: 2px solid #60A5FA;
        border-radius: 1rem;
        padding: 1.5rem;
        width: 95%;
        max-width: 500px;
        color: white;
        box-shadow: 0 0 20px rgba(96, 165, 250, 0.3), 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        max-height: 95vh;
        overflow-y: auto;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 2px solid #374151;
        padding-bottom: 1rem;
    }

    #modal-title {
        font-size: 1.5rem;
        font-weight: 800;
        color: #F3F4F6;
        margin: 0;
        text-shadow: 2px 2px 0px #374151;
        letter-spacing: 1px;
    }

    .header-controls {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    #close-modal-btn, #sound-toggle-btn {
        background: none;
        border: none;
        color: #9CA3AF;
        font-size: 1.5rem;
        line-height: 1;
        cursor: pointer;
        padding: 0.25rem;
        transition: color 0.2s;
    }

    #close-modal-btn:hover, #sound-toggle-btn:hover {
        color: white;
        transform: scale(1.1);
    }

    #game-menu {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .game-select-btn {
        background: linear-gradient(145deg, #374151, #1F2937);
        border: 2px solid #4B5563;
        padding: 1.25rem;
        border-radius: 0.75rem;
        color: white;
        font-size: 1.25rem;
        font-weight: 700;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        transition: all 0.2s;
        box-shadow: 0 4px 0 #111827;
        font-family: inherit;
    }

    .game-select-btn:hover {
        background: linear-gradient(145deg, #4B5563, #374151);
        transform: translateY(-2px);
        box-shadow: 0 6px 0 #111827;
        border-color: #60A5FA;
        color: #60A5FA;
    }

    .game-select-btn:active {
        transform: translateY(2px);
        box-shadow: 0 0 0 #111827;
    }

    .game-icon {
        font-size: 1.75rem;
    }

    #game-area.hidden {
        display: none;
    }

    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
    }

    .game-container.hidden {
        display: none;
    }

    .canvas-wrapper {
        position: relative;
        border: 4px solid #374151;
        border-radius: 0.5rem;
        padding: 4px;
        background-color: #111827;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
    }

    canvas {
        display: block;
        background-color: #000;
        image-rendering: pixelated;
        max-width: 100%;
    }

    .game-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }

    .game-overlay.hidden {
        display: none;
    }

    .overlay-title {
        font-size: 2rem;
        color: #EF4444;
        margin-bottom: 0.5rem;
        text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
    }

    .overlay-score {
        font-size: 1.25rem;
        margin-bottom: 1.5rem;
        color: #D1D5DB;
    }

    .overlay-btn {
        background-color: #10B981;
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        font-size: 1.25rem;
        font-weight: bold;
        border-radius: 0.5rem;
        cursor: pointer;
        font-family: inherit;
        box-shadow: 0 4px 0 #065F46;
        transition: transform 0.1s;
    }

    .overlay-btn:hover {
        background-color: #059669;
        transform: translateY(-2px);
        box-shadow: 0 6px 0 #065F46;
    }

    .overlay-btn:active {
        transform: translateY(2px);
        box-shadow: none;
    }

    .game-info {
        text-align: center;
        width: 100%;
        background-color: #374151;
        padding: 1rem;
        border-radius: 0.5rem;
        border: 1px solid #4B5563;
    }

    .score-display {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: #FCD34D;
        text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
    }

    .controls-hint {
        color: #9CA3AF;
        font-size: 0.75rem;
        margin-bottom: 1rem;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .restart-btn {
        background-color: #4B5563;
        color: white;
        border: 1px solid #6B7280;
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.875rem;
        transition: all 0.2s;
        font-family: inherit;
    }

    .restart-btn:hover {
        background-color: #6B7280;
        color: white;
    }

    #back-to-menu-btn {
        margin-top: 1rem;
        background: none;
        border: none;
        color: #9CA3AF;
        cursor: pointer;
        font-size: 0.875rem;
        text-decoration: underline;
        width: 100%;
        font-family: inherit;
    }

    #back-to-menu-btn:hover {
        color: white;
    }

    /* Tic-Tac-Toe Specific */
    #tictactoe-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.75rem;
        background-color: #1F2937;
        padding: 1rem;
        border-radius: 0.75rem;
        border: 2px solid #374151;
    }

    .ttt-cell {
        width: 5rem;
        height: 5rem;
        background-color: #111827;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3.5rem;
        font-weight: 900;
        color: white;
        cursor: pointer;
        user-select: none;
        border-radius: 0.5rem;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        transition: all 0.2s;
        position: relative;
    }

    .ttt-cell:hover:not(.filled) {
        background-color: #374151;
        transform: scale(0.95);
    }

    .ttt-cell.x { color: #60A5FA; text-shadow: 0 0 10px rgba(96, 165, 250, 0.5); }
    .ttt-cell.o { color: #F87171; text-shadow: 0 0 10px rgba(248, 113, 113, 0.5); }

    .status-msg {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        font-weight: bold;
        color: white;
    }

    /* Mobile adjustments */
    @media (max-width: 640px) {
        .modal-content { padding: 1rem; }
        .ttt-cell { width: 4rem; height: 4rem; font-size: 2.5rem; }
        canvas { max-height: 50vh; width: auto; }
    }
</style>

<script>
    // --- Sound Manager ---
    class SoundManager {
        constructor() {
            this.ctx = null;
            this.enabled = true;
            this.initialized = false;
        }

        init() {
            if (!this.initialized && (window.AudioContext || window.webkitAudioContext)) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
            }
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        }

        toggle() {
            this.enabled = !this.enabled;
            return this.enabled;
        }

        play(type) {
            if (!this.enabled || !this.ctx) return;

            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);

            const now = this.ctx.currentTime;

            switch (type) {
                case 'select':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'move':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, now);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
                case 'rotate':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.linearRampToValueAtTime(500, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
                case 'drop':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
                case 'clear':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.setValueAtTime(600, now + 0.1);
                    osc.frequency.setValueAtTime(800, now + 0.2);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0.1, now + 0.2);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now);
                    osc.stop(now + 0.4);
                    break;
                case 'eat':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'gameover':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                case 'win':
                    // Arpeggio
                    [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.connect(g);
                        g.connect(this.ctx.destination);
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.1, now + i * 0.1);
                        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);
                        o.start(now + i * 0.1);
                        o.stop(now + i * 0.1 + 0.2);
                    });
                    break;
            }
        }
    }

    const sound = new SoundManager();

    // --- State Management ---
    let currentGame = null;
    let gameLoopId = null;

    // --- DOM Elements ---
    const joystickBtn = document.getElementById('joystick-btn');
    const modal = document.getElementById('game-modal');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const soundToggleBtn = document.getElementById('sound-toggle-btn');
    const gameMenu = document.getElementById('game-menu');
    const gameArea = document.getElementById('game-area');
    const backToMenuBtn = document.getElementById('back-to-menu-btn');
    const gameButtons = document.querySelectorAll('.game-select-btn');

    // --- Event Listeners (Global) ---
    joystickBtn.addEventListener('click', () => {
        openModal();
        sound.init(); // Initialize audio context on user interaction
    });
    closeModalBtn.addEventListener('click', closeModal);
    backToMenuBtn.addEventListener('click', showMenu);
    soundToggleBtn.addEventListener('click', () => {
        const enabled = sound.toggle();
        soundToggleBtn.textContent = enabled ? 'üîä' : 'üîá';
    });

    gameButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            sound.play('select');
            const gameName = btn.dataset.game;
            startGame(gameName);
        });
    });

    document.getElementById('restart-tetris').addEventListener('click', () => initTetris());
    document.getElementById('restart-snake').addEventListener('click', () => initSnake());
    document.getElementById('restart-tictactoe').addEventListener('click', () => initTicTacToe());

    document.getElementById('tetris-retry').addEventListener('click', () => initTetris());
    document.getElementById('snake-retry').addEventListener('click', () => initSnake());

    // Global keyboard listener to prevent stacking
    document.addEventListener('keydown', (e) => {
        if (!currentGame || modal.classList.contains('hidden')) return;

        if (currentGame === 'snake') handleSnakeInput(e);
        if (currentGame === 'tetris') handleTetrisInput(e);
    });

    // --- Modal Logic ---
    function openModal() {
        modal.classList.remove('hidden');
        showMenu();
    }

    function closeModal() {
        modal.classList.add('hidden');
        stopGameLoop();
        currentGame = null;
    }

    function showMenu() {
        stopGameLoop();
        gameMenu.classList.remove('hidden');
        gameArea.classList.add('hidden');
        document.querySelectorAll('.game-container').forEach(el => el.classList.add('hidden'));
        document.getElementById('modal-title').textContent = "Arcade Center";
        sound.play('select');
    }

    function startGame(gameName) {
        gameMenu.classList.add('hidden');
        gameArea.classList.remove('hidden');
        currentGame = gameName;

        document.querySelectorAll('.game-container').forEach(el => el.classList.add('hidden'));

        if (gameName === 'tetris') {
            document.getElementById('tetris-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Tetris";
            initTetris();
        } else if (gameName === 'snake') {
            document.getElementById('snake-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Snake";
            initSnake();
        } else if (gameName === 'tictactoe') {
            document.getElementById('tictactoe-container').classList.remove('hidden');
            document.getElementById('modal-title').textContent = "Tic-Tac-Toe";
            initTicTacToe();
        }
    }

    function stopGameLoop() {
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
        }
        if (snakeInterval) {
            clearInterval(snakeInterval);
            snakeInterval = null;
        }
    }

    // ==========================================
    // TIC-TAC-TOE
    // ==========================================
    let tttBoard = Array(9).fill(null);
    let tttPlayer = 'X';
    let tttActive = true;

    function initTicTacToe() {
        tttBoard = Array(9).fill(null);
        tttPlayer = 'X';
        tttActive = true;
        updateTicTacToeUI();
    }

    function updateTicTacToeUI() {
        const boardEl = document.getElementById('tictactoe-board');
        boardEl.innerHTML = '';
        const statusEl = document.getElementById('tictactoe-status');

        tttBoard.forEach((cell, index) => {
            const cellEl = document.createElement('div');
            cellEl.classList.add('ttt-cell');
            if (cell) {
                cellEl.classList.add(cell.toLowerCase(), 'filled');
            }
            cellEl.textContent = cell || '';
            cellEl.addEventListener('click', () => handleTicTacToeClick(index));
            boardEl.appendChild(cellEl);
        });

        if (checkTicTacToeWin()) {
            statusEl.textContent = `Player ${tttPlayer === 'X' ? 'O' : 'X'} Wins!`;
            statusEl.style.color = tttPlayer === 'X' ? '#F87171' : '#60A5FA'; // Winner color
            tttActive = false;
            sound.play('win');
        } else if (!tttBoard.includes(null)) {
            statusEl.textContent = "It's a Draw!";
            statusEl.style.color = '#fff';
            tttActive = false;
            sound.play('gameover');
        } else {
            statusEl.textContent = `Player ${tttPlayer}'s Turn`;
            statusEl.style.color = tttPlayer === 'X' ? '#60A5FA' : '#F87171';
        }
    }

    function handleTicTacToeClick(index) {
        if (!tttActive || tttBoard[index]) return;
        sound.play('move');
        tttBoard[index] = tttPlayer;
        if (!checkTicTacToeWin()) {
            tttPlayer = tttPlayer === 'X' ? 'O' : 'X';
        }
        updateTicTacToeUI();
    }

    function checkTicTacToeWin() {
        const wins = [
            [0,1,2], [3,4,5], [6,7,8], // Rows
            [0,3,6], [1,4,7], [2,5,8], // Cols
            [0,4,8], [2,4,6]           // Diags
        ];
        return wins.some(combo => {
            const [a, b, c] = combo;
            return tttBoard[a] && tttBoard[a] === tttBoard[b] && tttBoard[a] === tttBoard[c];
        });
    }

    // ==========================================
    // SNAKE
    // ==========================================
    let snakeCanvas, snakeCtx;
    let snake = [];
    let snakeFood = {};
    let snakeDir = 'right';
    let snakeNextDir = 'right';
    let snakeScore = 0;
    let snakeInterval = null;
    const snakeGrid = 20;

    function initSnake() {
        stopGameLoop();
        document.getElementById('snake-overlay').classList.add('hidden');
        snakeCanvas = document.getElementById('snake-canvas');
        snakeCtx = snakeCanvas.getContext('2d');

        snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
        snakeDir = 'right';
        snakeNextDir = 'right';
        snakeScore = 0;
        document.getElementById('snake-score').textContent = snakeScore;
        placeSnakeFood();

        // Use SetInterval for Snake speed control
        snakeInterval = setInterval(updateSnake, 100);
        sound.play('select');
    }

    function handleSnakeInput(e) {
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        switch(e.key) {
            case 'ArrowUp': if (snakeDir !== 'down') snakeNextDir = 'up'; break;
            case 'ArrowDown': if (snakeDir !== 'up') snakeNextDir = 'down'; break;
            case 'ArrowLeft': if (snakeDir !== 'right') snakeNextDir = 'left'; break;
            case 'ArrowRight': if (snakeDir !== 'left') snakeNextDir = 'right'; break;
        }
    }

    function placeSnakeFood() {
        snakeFood = {
            x: Math.floor(Math.random() * (snakeCanvas.width / snakeGrid)),
            y: Math.floor(Math.random() * (snakeCanvas.height / snakeGrid))
        };
        // Ensure food doesn't spawn on snake
        if (snake.some(seg => seg.x === snakeFood.x && seg.y === snakeFood.y)) {
            placeSnakeFood();
        }
    }

    function updateSnake() {
        if (!currentGame) return;

        snakeDir = snakeNextDir;
        const head = { ...snake[0] };

        if (snakeDir === 'right') head.x++;
        if (snakeDir === 'left') head.x--;
        if (snakeDir === 'up') head.y--;
        if (snakeDir === 'down') head.y++;

        // Collision Check
        if (head.x < 0 || head.x >= snakeCanvas.width / snakeGrid ||
            head.y < 0 || head.y >= snakeCanvas.height / snakeGrid ||
            snake.some(seg => seg.x === head.x && seg.y === head.y)) {
            gameOverSnake();
            return;
        }

        snake.unshift(head);

        if (head.x === snakeFood.x && head.y === snakeFood.y) {
            snakeScore += 10;
            document.getElementById('snake-score').textContent = snakeScore;
            sound.play('eat');
            placeSnakeFood();
        } else {
            snake.pop();
        }

        drawSnake();
    }

    function drawSnake() {
        // Clear & Grid
        snakeCtx.fillStyle = '#111827';
        snakeCtx.fillRect(0, 0, snakeCanvas.width, snakeCanvas.height);
        snakeCtx.strokeStyle = '#1F2937';
        snakeCtx.lineWidth = 1;
        for(let i=0; i<snakeCanvas.width; i+=snakeGrid) {
            snakeCtx.beginPath(); snakeCtx.moveTo(i,0); snakeCtx.lineTo(i,snakeCanvas.height); snakeCtx.stroke();
            snakeCtx.beginPath(); snakeCtx.moveTo(0,i); snakeCtx.lineTo(snakeCanvas.width,i); snakeCtx.stroke();
        }

        // Food
        snakeCtx.fillStyle = '#EF4444';
        snakeCtx.beginPath();
        snakeCtx.arc(snakeFood.x * snakeGrid + snakeGrid/2, snakeFood.y * snakeGrid + snakeGrid/2, snakeGrid/2 - 2, 0, Math.PI*2);
        snakeCtx.fill();
        snakeCtx.shadowColor = '#EF4444';
        snakeCtx.shadowBlur = 10;
        snakeCtx.fill(); // Glow
        snakeCtx.shadowBlur = 0;

        // Snake
        snakeCtx.fillStyle = '#10B981';
        snake.forEach((seg, index) => {
            const isHead = index === 0;
            const x = seg.x * snakeGrid;
            const y = seg.y * snakeGrid;
            const s = snakeGrid - 2;

            snakeCtx.fillStyle = isHead ? '#34D399' : '#059669';
            snakeCtx.beginPath();
            snakeCtx.roundRect(x+1, y+1, s, s, isHead ? 6 : 4);
            snakeCtx.fill();

            // Eyes for head
            if (isHead) {
                snakeCtx.fillStyle = '#111827';
                let eyeOffsetX = 0, eyeOffsetY = 0;
                if (snakeDir === 'right') eyeOffsetX = 4;
                if (snakeDir === 'left') eyeOffsetX = -4;
                if (snakeDir === 'up') eyeOffsetY = -4;
                if (snakeDir === 'down') eyeOffsetY = 4;

                snakeCtx.beginPath();
                snakeCtx.arc(x + snakeGrid/2 + eyeOffsetX, y + snakeGrid/2 + eyeOffsetY, 2, 0, Math.PI*2);
                snakeCtx.fill();
            }
        });
    }

    function gameOverSnake() {
        stopGameLoop();
        sound.play('gameover');
        document.getElementById('snake-final-score').textContent = snakeScore;
        document.getElementById('snake-overlay').classList.remove('hidden');
    }

    // ==========================================
    // TETRIS
    // ==========================================
    const tetrisCols = 10;
    const tetrisRows = 20;
    const blockSize = 24;
    let tetrisCanvas, tetrisCtx;
    let tetrisBoard = [];
    let tetrisScore = 0;
    let currentPiece = null;
    let lastTime = 0;
    let dropCounter = 0;
    let dropInterval = 1000;

    const pieces = 'ILJOTSZ';
    const shapes = {
        'I': [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
        'L': [[0,0,1], [1,1,1], [0,0,0]],
        'J': [[1,0,0], [1,1,1], [0,0,0]],
        'O': [[1,1], [1,1]],
        'Z': [[1,1,0], [0,1,1], [0,0,0]],
        'S': [[0,1,1], [1,1,0], [0,0,0]],
        'T': [[0,1,0], [1,1,1], [0,0,0]]
    };
    const colors = {
        'I': '#22d3ee', 'O': '#fbbf24', 'T': '#a78bfa',
        'S': '#4ade80', 'Z': '#f87171', 'J': '#60a5fa', 'L': '#fb923c'
    };

    function initTetris() {
        stopGameLoop();
        document.getElementById('tetris-overlay').classList.add('hidden');
        tetrisCanvas = document.getElementById('tetris-canvas');
        tetrisCtx = tetrisCanvas.getContext('2d');

        tetrisBoard = Array(tetrisRows).fill().map(() => Array(tetrisCols).fill(0));
        tetrisScore = 0;
        document.getElementById('tetris-score').textContent = tetrisScore;

        resetPiece();
        dropCounter = 0;
        lastTime = 0;

        gameLoopId = requestAnimationFrame(updateTetris);
        sound.play('select');
    }

    function resetPiece() {
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        currentPiece = {
            matrix: shapes[type],
            pos: {x: Math.floor(tetrisCols / 2) - 1, y: 0},
            type: type
        };
        if (collide(tetrisBoard, currentPiece)) {
            gameOverTetris();
        }
    }

    function collide(board, piece) {
        const m = piece.matrix;
        const o = piece.pos;
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 &&
                   (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function drawBlock(x, y, color) {
        const size = blockSize;
        const posX = x * size;
        const posY = y * size;

        // Base fill
        tetrisCtx.fillStyle = color;
        tetrisCtx.fillRect(posX, posY, size, size);

        // Bevel highlights
        tetrisCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        tetrisCtx.fillRect(posX, posY, size, 2); // Top
        tetrisCtx.fillRect(posX, posY, 2, size); // Left

        // Bevel shadows
        tetrisCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        tetrisCtx.fillRect(posX, posY + size - 2, size, 2); // Bottom
        tetrisCtx.fillRect(posX + size - 2, posY, 2, size); // Right

        // Border
        tetrisCtx.strokeStyle = 'rgba(0,0,0,0.5)';
        tetrisCtx.lineWidth = 1;
        tetrisCtx.strokeRect(posX, posY, size, size);
    }

    function drawMatrix(matrix, offset, ghost = false) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    const type = typeof value === 'string' ? value : currentPiece.type;
                    const color = colors[type];
                    if (ghost) {
                        tetrisCtx.globalAlpha = 0.2;
                        drawBlock(x + offset.x, y + offset.y, color);
                        tetrisCtx.globalAlpha = 1.0;
                    } else {
                        drawBlock(x + offset.x, y + offset.y, color);
                    }
                }
            });
        });
    }

    function drawTetris() {
        // Clear
        tetrisCtx.fillStyle = '#111827';
        tetrisCtx.fillRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);

        // Grid lines (subtle)
        tetrisCtx.strokeStyle = '#1F2937';
        tetrisCtx.lineWidth = 1;
        for(let i=0; i<tetrisCols; i++) {
            tetrisCtx.beginPath(); tetrisCtx.moveTo(i*blockSize,0); tetrisCtx.lineTo(i*blockSize, tetrisCanvas.height); tetrisCtx.stroke();
        }
        for(let i=0; i<tetrisRows; i++) {
            tetrisCtx.beginPath(); tetrisCtx.moveTo(0, i*blockSize); tetrisCtx.lineTo(tetrisCanvas.width, i*blockSize); tetrisCtx.stroke();
        }

        drawMatrix(tetrisBoard, {x: 0, y: 0});

        // Ghost Piece
        if (currentPiece) {
            let ghostY = currentPiece.pos.y;
            while(!collide(tetrisBoard, { ...currentPiece, pos: { x: currentPiece.pos.x, y: ghostY + 1 } })) {
                ghostY++;
            }
            drawMatrix(currentPiece.matrix, { x: currentPiece.pos.x, y: ghostY }, true);

            // Active Piece
            drawMatrix(currentPiece.matrix, currentPiece.pos);
        }
    }

    function merge(board, piece) {
        piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    board[y + piece.pos.y][x + piece.pos.x] = piece.type;
                }
            });
        });
    }

    function rotate(matrix, dir) {
        for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
                [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
        }
        if (dir > 0) matrix.forEach(row => row.reverse());
        else matrix.reverse();
    }

    function playerRotate(dir) {
        const pos = currentPiece.pos.x;
        let offset = 1;
        rotate(currentPiece.matrix, dir);
        while (collide(tetrisBoard, currentPiece)) {
            currentPiece.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > currentPiece.matrix[0].length) {
                rotate(currentPiece.matrix, -dir);
                currentPiece.pos.x = pos;
                return;
            }
        }
        sound.play('rotate');
    }

    function arenaSweep() {
        let rowCount = 0;
        outer: for (let y = tetrisBoard.length -1; y > 0; --y) {
            for (let x = 0; x < tetrisBoard[y].length; ++x) {
                if (tetrisBoard[y][x] === 0) {
                    continue outer;
                }
            }
            const row = tetrisBoard.splice(y, 1)[0].fill(0);
            tetrisBoard.unshift(row);
            ++y;
            rowCount++;
        }
        if (rowCount > 0) {
            tetrisScore += rowCount * 10 * rowCount;
            document.getElementById('tetris-score').textContent = tetrisScore;
            sound.play('clear');
        }
    }

    function playerDrop() {
        currentPiece.pos.y++;
        if (collide(tetrisBoard, currentPiece)) {
            currentPiece.pos.y--;
            merge(tetrisBoard, currentPiece);
            sound.play('drop');
            resetPiece();
            arenaSweep();
        }
        dropCounter = 0;
    }

    function updateTetris(time = 0) {
        if (!currentGame) return;

        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            playerDrop();
        }
        drawTetris();
        gameLoopId = requestAnimationFrame(updateTetris);
    }

    function gameOverTetris() {
        stopGameLoop();
        sound.play('gameover');
        document.getElementById('tetris-final-score').textContent = tetrisScore;
        document.getElementById('tetris-overlay').classList.remove('hidden');
    }

    function handleTetrisInput(e) {
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        if (e.key === 'ArrowLeft') {
            currentPiece.pos.x--;
            if (collide(tetrisBoard, currentPiece)) {
                currentPiece.pos.x++;
            } else {
                sound.play('move');
            }
        } else if (e.key === 'ArrowRight') {
            currentPiece.pos.x++;
            if (collide(tetrisBoard, currentPiece)) {
                currentPiece.pos.x--;
            } else {
                sound.play('move');
            }
        } else if (e.key === 'ArrowDown') {
            playerDrop();
        } else if (e.key === 'ArrowUp') {
            playerRotate(1);
        }
    }
</script>
