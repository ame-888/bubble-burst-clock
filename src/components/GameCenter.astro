---
---
<div id="game-center-container">
    <button id="joystick-btn" aria-label="Open Game Center" title="Play Games">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="joystick-icon">
            <rect x="2" y="6" width="20" height="12" rx="2"></rect>
            <path d="M6 12h4"></path>
            <path d="M8 10v4"></path>
            <line x1="15" y1="13" x2="15.01" y2="13"></line>
            <line x1="18" y1="11" x2="18.01" y2="11"></line>
        </svg>
    </button>

    <div id="game-modal" class="hidden">
        <div class="modal-overlay"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">AI Arcade</h2>
                <button id="close-modal-btn" aria-label="Close">&times;</button>
            </div>

            <div id="game-menu">
                <button class="game-select-btn" data-game="tetris">
                    <span class="game-icon">üß©</span> Cluster Builder
                </button>
                <button class="game-select-btn" data-game="snake">
                    <span class="game-icon">üß¨</span> Data Stream
                </button>
                <button class="game-select-btn" data-game="breakout">
                    <span class="game-icon">üõ°Ô∏è</span> Firewall Breaker
                </button>
                <button class="game-select-btn" data-game="tictactoe">
                    <span class="game-icon">üß†</span> Neural Nodes
                </button>
                <button class="game-select-btn" id="leaderboard-btn" style="margin-top: 1rem; border-color: #F59E0B; color: #F59E0B;">
                    <span class="game-icon">üèÜ</span> High Scores
                </button>
            </div>

            <div id="leaderboard-view" class="hidden">
                <h3>Top Scores</h3>
                <div id="leaderboard-content"></div>
                <button id="back-from-leaderboard-btn" class="menu-back-btn">‚Üê Back to Menu</button>
            </div>

            <div id="game-area" class="hidden">
                <div class="game-canvas-wrapper">
                    <canvas id="game-canvas" width="400" height="400"></canvas>
                    <div id="game-overlay" class="hidden">
                        <h3 id="game-overlay-title">Game Over</h3>
                        <p id="game-overlay-score">Score: 0</p>
                        <button id="game-restart-btn">Play Again</button>
                        <button id="game-quit-btn">Quit to Menu</button>
                    </div>
                </div>

                <div class="game-controls-info">
                    <div class="score-display">Score: <span id="current-score">0</span></div>
                    <!-- Pause button removed, using 'P' key -->
                    <p id="controls-hint">Controls Info</p>
                    <button id="back-to-menu-btn" class="menu-back-btn">‚Üê Back to Menu</button>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    /* --- Styles --- */
    #joystick-btn {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999; /* Ensure visibility */
        background-color: #1F2937;
        color: #60A5FA;
        border: 2px solid #60A5FA;
        border-radius: 50%;
        width: 4rem;
        height: 4rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 0 15px rgba(96, 165, 250, 0.5);
    }

    #joystick-btn:hover {
        background-color: #374151;
        transform: translateX(-50%) scale(1.1);
        box-shadow: 0 0 25px rgba(96, 165, 250, 0.8);
    }

    .joystick-icon {
        width: 2rem;
        height: 2rem;
    }

    #game-modal {
        position: fixed;
        inset: 0;
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Force hide hidden elements */
    .hidden { display: none !important; }

    #game-modal.hidden {
        display: none !important;
    }

    .modal-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(8px);
    }

    .modal-content {
        position: relative;
        background-color: #111827;
        border: 1px solid #374151;
        border-radius: 1rem;
        padding: 1.5rem;
        width: 95%;
        max-width: 500px;
        color: white;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        max-height: 90vh;
        overflow-y: auto;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #374151;
        padding-bottom: 1rem;
    }

    #modal-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #60A5FA;
        margin: 0;
        text-shadow: 0 0 10px rgba(96, 165, 250, 0.3);
    }

    #close-modal-btn {
        background: none;
        border: none;
        color: #9CA3AF;
        font-size: 2rem;
        line-height: 1;
        cursor: pointer;
        transition: color 0.2s;
    }

    #close-modal-btn:hover { color: white; }

    #game-menu {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        overflow-y: auto;
    }

    .game-select-btn {
        background-color: #1F2937;
        border: 1px solid #374151;
        padding: 1rem;
        border-radius: 0.75rem;
        color: white;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        transition: all 0.2s;
    }

    .game-select-btn:hover {
        background-color: #374151;
        border-color: #60A5FA;
        transform: translateY(-2px);
    }

    #game-area.hidden { display: none !important; }
    #leaderboard-view.hidden { display: none !important; }
    #game-menu.hidden { display: none !important; }

    .game-canvas-wrapper {
        position: relative;
        width: 100%;
        aspect-ratio: 1; /* Keep square mostly */
        background-color: #030712;
        border: 2px solid #374151;
        border-radius: 0.5rem;
        overflow: hidden;
        margin-bottom: 1rem;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #game-overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        z-index: 10;
    }

    #game-overlay.hidden { display: none; }

    #game-overlay-title {
        font-size: 2rem;
        color: #F87171;
        margin: 0;
        font-weight: 800;
    }

    #game-overlay button {
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        border: none;
        font-weight: 600;
        cursor: pointer;
        width: 80%;
    }

    #game-restart-btn { background-color: #10B981; color: white; }
    #game-restart-btn:hover { background-color: #059669; }

    #game-quit-btn { background-color: #4B5563; color: white; margin-top: 0.5rem; }
    #game-quit-btn:hover { background-color: #374151; }

    .game-controls-info { text-align: center; }

    .score-display {
        font-size: 1.5rem;
        font-weight: bold;
        color: #60A5FA;
        margin-bottom: 0.5rem;
    }

    #controls-hint {
        color: #9CA3AF;
        font-size: 0.9rem;
        margin-bottom: 1rem;
    }

    .menu-back-btn {
        background: none;
        border: none;
        color: #9CA3AF;
        cursor: pointer;
        font-size: 0.9rem;
        text-decoration: underline;
    }
    .menu-back-btn:hover { color: white; }

    /* Leaderboard Styles */
    #leaderboard-view { text-align: center; }
    #leaderboard-view h3 { color: #F59E0B; margin-top: 0; }

    .leaderboard-game-section {
        margin-bottom: 1.5rem;
        border-bottom: 1px solid #374151;
        padding-bottom: 0.5rem;
        text-align: left;
    }

    .leaderboard-game-title {
        font-weight: bold;
        color: #60A5FA;
        font-size: 0.9rem;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
    }

    .leaderboard-list {
        list-style: none;
        padding: 0;
        margin: 0;
        font-size: 0.9rem;
    }

    .leaderboard-list li {
        display: flex;
        justify-content: space-between;
        padding: 0.25rem 0;
        color: #D1D5DB;
        border-bottom: 1px dashed #374151;
    }
    .leaderboard-list li:last-child { border-bottom: none; }
</style>

<script>
    // --- UTILITIES ---
    class SoundManager {
        constructor() {
            this.ctx = null;
            this.enabled = true;
        }

        init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        }

        play(type) {
            if (!this.enabled) return;
            this.init();

            const now = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.connect(gain);
            gain.connect(this.ctx.destination);

            switch (type) {
                case 'pop': // Bubble Pop
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'move': // Soft blip
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
                case 'bounce': // Ball bounce
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(300, now + 0.05);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
                case 'score': // High ping
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                    break;
                case 'gameover': // Deep wobble
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.exponentialRampToValueAtTime(20, now + 1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 1);
                    osc.start(now);
                    osc.stop(now + 1);
                    break;
            }
        }
    }

    class MusicManager {
        constructor() {
            this.ctx = null;
            this.isPlaying = false;
            this.timer = null;
            this.noteIndex = 0;
            this.currentTrack = null;
            this.tempo = 140;

            // NOTE: Frequencies
            // E4: 329.63, A4: 440, B4: 493.88, C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99, A5: 880

            // Extended Jazzy Korobeiniki (Tetris)
            this.tracks = {
                tetris: {
                    tempo: 140,
                    notes: [
                        // Part A (Classic)
                        // E B C D C B
                        {f: 659.25, d: 1}, {f: 493.88, d: 0.5}, {f: 523.25, d: 0.5}, {f: 587.33, d: 1}, {f: 523.25, d: 0.5}, {f: 493.88, d: 0.5},
                        // A A C E D C
                        {f: 440.00, d: 1}, {f: 440.00, d: 0.5}, {f: 523.25, d: 0.5}, {f: 659.25, d: 1}, {f: 587.33, d: 0.5}, {f: 523.25, d: 0.5},
                        // B C D E
                        {f: 493.88, d: 1.5}, {f: 523.25, d: 0.5}, {f: 587.33, d: 1}, {f: 659.25, d: 1},
                        // C A A
                        {f: 523.25, d: 1}, {f: 440.00, d: 1}, {f: 440.00, d: 2},
                        // Rest
                        {f: 0, d: 0.5},

                        // Part B (High Section)
                        // D D F A G F
                        {f: 587.33, d: 1.5}, {f: 698.46, d: 0.5}, {f: 880.00, d: 1}, {f: 783.99, d: 0.5}, {f: 698.46, d: 0.5},
                        // E C E D C
                        {f: 659.25, d: 1.5}, {f: 523.25, d: 0.5}, {f: 659.25, d: 1}, {f: 587.33, d: 0.5}, {f: 523.25, d: 0.5},
                        // B B C D E
                        {f: 493.88, d: 1}, {f: 493.88, d: 0.5}, {f: 523.25, d: 0.5}, {f: 587.33, d: 1}, {f: 659.25, d: 1},
                        // C A A
                        {f: 523.25, d: 1}, {f: 440.00, d: 1}, {f: 440.00, d: 2},

                        // Part C (Improv/Bridge)
                        {f: 440.00, d: 0.33}, {f: 523.25, d: 0.33}, {f: 659.25, d: 0.33}, {f: 587.33, d: 1}, // Triplet up
                        {f: 493.88, d: 0.5}, {f: 0, d: 0.5}, // Staccato
                        {f: 440.00, d: 0.5}, {f: 415.30, d: 0.5}, {f: 440.00, d: 2}, // Resolution
                        {f: 0, d: 1},
                    ]
                },
                breakout: {
                    tempo: 160, // Faster
                    notes: [
                        // Arpeggio C minor: C Eb G C
                        {f: 261.63, d: 0.5}, {f: 311.13, d: 0.5}, {f: 392.00, d: 0.5}, {f: 523.25, d: 0.5},
                        // Down G Eb C
                        {f: 392.00, d: 0.5}, {f: 311.13, d: 0.5}, {f: 261.63, d: 1},
                        // Arpeggio Bb major: Bb D F Bb
                        {f: 233.08, d: 0.5}, {f: 293.66, d: 0.5}, {f: 349.23, d: 0.5}, {f: 466.16, d: 0.5},
                        // Down F D Bb
                        {f: 349.23, d: 0.5}, {f: 293.66, d: 0.5}, {f: 233.08, d: 1},
                        // Repeat C minor variant
                        {f: 261.63, d: 0.25}, {f: 392.00, d: 0.25}, {f: 261.63, d: 0.25}, {f: 392.00, d: 0.25},
                        {f: 523.25, d: 2},
                    ]
                }
            };
        }

        init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') this.ctx.resume();
        }

        start(trackName) {
            if (this.isPlaying && this.currentTrack === trackName) return;
            this.stop();

            this.init();
            this.isPlaying = true;
            this.currentTrack = trackName;
            this.noteIndex = 0;
            this.tempo = this.tracks[trackName].tempo;
            this.playNext();
        }

        stop() {
            this.isPlaying = false;
            this.currentTrack = null;
            if (this.timer) clearTimeout(this.timer);
        }

        playNext() {
            if (!this.isPlaying || !this.currentTrack) return;

            const track = this.tracks[this.currentTrack];
            const note = track.notes[this.noteIndex];

            // 60 / tempo = seconds per beat
            const beatLen = (60 / this.tempo) * 1000;
            const duration = note.d * beatLen;

            if (note.f > 0) {
                this.playTone(note.f, duration);
            }

            this.noteIndex = (this.noteIndex + 1) % track.notes.length;
            this.timer = setTimeout(() => this.playNext(), duration);
        }

        playTone(freq, dur) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.type = this.currentTrack === 'breakout' ? 'sawtooth' : 'triangle';
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

            // Envelope
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur/1000);

            osc.connect(gain);
            gain.connect(this.ctx.destination);

            osc.start();
            osc.stop(this.ctx.currentTime + dur/1000);
        }
    }

    class ScoreManager {
        constructor() {
            this.key = 'ai_arcade_scores';
        }

        getScores() {
            const defaults = { tetris: [], snake: [], breakout: [], tictactoe: 0 };
            try {
                const stored = JSON.parse(localStorage.getItem(this.key));
                return { ...defaults, ...stored };
            } catch (e) {
                return defaults;
            }
        }

        saveScore(game, score) {
            const scores = this.getScores();
            let isHigh = false;

            if (game === 'tictactoe') {
                if (score > (scores.tictactoe || 0)) {
                    scores.tictactoe = score;
                    isHigh = true;
                }
            } else {
                if (!scores[game]) scores[game] = [];
                scores[game].push({ score, date: new Date().toISOString() });
                scores[game].sort((a, b) => b.score - a.score);
                scores[game] = scores[game].slice(0, 5);
                isHigh = scores[game].some(s => s.score === score);
            }

            try {
                localStorage.setItem(this.key, JSON.stringify(scores));
            } catch (e) { console.error('Score save failed', e); }

            return isHigh;
        }
    }

    // --- GAME ENGINE ---
    document.addEventListener('DOMContentLoaded', () => {
        // Elements
        const joystickBtn = document.getElementById('joystick-btn');
        const modal = document.getElementById('game-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const gameMenu = document.getElementById('game-menu');
        const gameArea = document.getElementById('game-area');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const currentScoreEl = document.getElementById('current-score');
        const controlsHintEl = document.getElementById('controls-hint');
        const gameOverlay = document.getElementById('game-overlay');
        const gameOverlayTitle = document.getElementById('game-overlay-title');
        const gameOverlayScore = document.getElementById('game-overlay-score');
        const gameRestartBtn = document.getElementById('game-restart-btn');
        const gameQuitBtn = document.getElementById('game-quit-btn');
        const leaderboardBtn = document.getElementById('leaderboard-btn');
        const leaderboardView = document.getElementById('leaderboard-view');
        const leaderboardContent = document.getElementById('leaderboard-content');
        const backFromLeaderboardBtn = document.getElementById('back-from-leaderboard-btn');

        // Utils
        const sound = new SoundManager();
        const music = new MusicManager();
        const scores = new ScoreManager();

        // State
        let currentGame = null;
        let gameLoopId = null;
        let lastTime = 0;
        let gameActive = false;
        let isPaused = false;

        // Game States
        let snakeState = {};
        let tetrisState = {};
        let tttState = {};
        let breakoutState = {};

        // --- HANDLERS ---
        joystickBtn.addEventListener('click', () => {
            modal.classList.remove('hidden');
            showMenu();
        });

        closeModalBtn.addEventListener('click', () => {
            stopGame();
            modal.classList.add('hidden');
        });

        backToMenuBtn.addEventListener('click', () => {
            stopGame();
            showMenu();
        });

        gameQuitBtn.addEventListener('click', () => {
            stopGame();
            showMenu();
        });

        gameRestartBtn.addEventListener('click', () => {
            gameOverlay.classList.add('hidden');
            if (currentGame === 'snake') initSnake();
            else if (currentGame === 'tetris') initTetris();
            else if (currentGame === 'breakout') initBreakout();
            else if (currentGame === 'tictactoe') initTicTacToe();
        });

        leaderboardBtn.addEventListener('click', showLeaderboard);
        backFromLeaderboardBtn.addEventListener('click', showMenu);

        document.querySelectorAll('.game-select-btn').forEach(btn => {
            if (btn.id === 'leaderboard-btn') return;
            btn.addEventListener('click', () => {
                const game = btn.dataset.game;
                startGame(game);
            });
        });

        // Input
        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;

            // Pause toggle
            if (e.key.toLowerCase() === 'p' && currentGame !== 'tictactoe') {
                 isPaused = !isPaused;
                 return;
            }

            if (isPaused) return;

            // Prevent scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }

            if (currentGame === 'snake') handleSnakeInput(e);
            if (currentGame === 'tetris') handleTetrisInput(e);
            if (currentGame === 'breakout') handleBreakoutInput(e);
        });

        canvas.addEventListener('mousedown', (e) => {
             if (!gameActive || isPaused || currentGame !== 'tictactoe') return;
             handleTicTacToeClick(e);
        });

        function showMenu() {
            gameMenu.classList.remove('hidden');
            gameArea.classList.add('hidden');
            leaderboardView.classList.add('hidden');
            document.getElementById('modal-title').textContent = "AI Arcade";
        }

        function showLeaderboard() {
            gameMenu.classList.add('hidden');
            leaderboardView.classList.remove('hidden');
            const data = scores.getScores();

            const fmtDate = (d) => new Date(d).toLocaleDateString();

            let html = '';

            // Tetris
            html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Cluster Builder</div><ul class="leaderboard-list">`;
            data.tetris.forEach(s => html += `<li><span>${fmtDate(s.date)}</span><span>${s.score}</span></li>`);
            html += `</ul></div>`;

            // Snake
            html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Data Stream</div><ul class="leaderboard-list">`;
            data.snake.forEach(s => html += `<li><span>${fmtDate(s.date)}</span><span>${s.score}</span></li>`);
            html += `</ul></div>`;

            // Breakout
            html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Firewall Breaker</div><ul class="leaderboard-list">`;
            (data.breakout || []).forEach(s => html += `<li><span>${fmtDate(s.date)}</span><span>${s.score}</span></li>`);
            html += `</ul></div>`;

            // TTT
            html += `<div class="leaderboard-game-section"><div class="leaderboard-game-title">Neural Nodes (Streak)</div><ul class="leaderboard-list">`;
            html += `<li><span>Best Streak</span><span>${data.tictactoe || 0}</span></li>`;
            html += `</ul></div>`;

            leaderboardContent.innerHTML = html;
        }

        function startGame(game) {
            currentGame = game;
            gameMenu.classList.add('hidden');
            gameArea.classList.remove('hidden');
            gameOverlay.classList.add('hidden');
            canvas.width = 400;
            canvas.height = 400; // Reset size
            isPaused = false;

            if (game === 'snake') initSnake();
            else if (game === 'tetris') initTetris();
            else if (game === 'breakout') initBreakout();
            else if (game === 'tictactoe') initTicTacToe();
        }

        function stopGame() {
            gameActive = false;
            music.stop();
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
        }

        function gameOver(score) {
            gameActive = false;
            sound.play('gameover');
            music.stop();
            scores.saveScore(currentGame, score);

            gameOverlayTitle.textContent = "System Failure";
            if (currentGame === 'tictactoe' && score > 0) gameOverlayTitle.textContent = "Victory!"; // Handle TTT differently usually

            gameOverlayScore.textContent = `Score: ${score}`;
            gameOverlay.classList.remove('hidden');
        }

        function loop(time) {
            if (!gameActive) return;
            gameLoopId = requestAnimationFrame(loop);

            if (isPaused) {
                lastTime = time; // Prevent dt jump

                // Draw Pause Overlay
                ctx.save();
                // We don't clear, just overlay.
                // But to prevent intense layering opacity, we can just draw text if we want.
                // Or clear and redraw last state? No, that's complex.
                // Just draw a semi-opaque box once? Hard in a loop.
                // Let's just draw the text on top, maybe a small background box for text.

                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(canvas.width/2 - 80, canvas.height/2 - 30, 160, 60);

                ctx.fillStyle = '#F59E0B';
                ctx.font = 'bold 30px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'black';
                ctx.fillText("PAUSED", canvas.width/2, canvas.height/2);
                ctx.restore();

                return;
            }

            const dt = time - lastTime;
            lastTime = time;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (currentGame === 'snake') updateSnake(dt);
            if (currentGame === 'tetris') updateTetris(dt);
            if (currentGame === 'breakout') updateBreakout(dt);
            if (currentGame === 'tictactoe') drawTicTacToe();
        }

        // --- SNAKE: DATA STREAM ---
        function initSnake() {
            document.getElementById('modal-title').textContent = "Data Stream";
            controlsHintEl.textContent = "Arrow Keys to direct. 'P' to Pause.";
            snakeState = {
                grid: 20,
                snake: [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}],
                dir: {x: 1, y: 0},
                nextDir: {x: 1, y: 0},
                food: null,
                score: 0,
                speed: 100, // ms per move
                timer: 0
            };
            spawnSnakeFood();
            gameActive = true;
            lastTime = performance.now();
            music.stop(); // No music for snake currently? Or add? Let's leave it silent or add later if requested.
            loop(lastTime);
        }

        function spawnSnakeFood() {
            const cols = canvas.width / snakeState.grid;
            const rows = canvas.height / snakeState.grid;
            snakeState.food = {
                x: Math.floor(Math.random() * cols),
                y: Math.floor(Math.random() * rows)
            };
        }

        function handleSnakeInput(e) {
            const { dir } = snakeState;
            switch(e.key) {
                case 'ArrowUp': if (dir.y === 0) snakeState.nextDir = {x: 0, y: -1}; break;
                case 'ArrowDown': if (dir.y === 0) snakeState.nextDir = {x: 0, y: 1}; break;
                case 'ArrowLeft': if (dir.x === 0) snakeState.nextDir = {x: -1, y: 0}; break;
                case 'ArrowRight': if (dir.x === 0) snakeState.nextDir = {x: 1, y: 0}; break;
            }
        }

        function updateSnake(dt) {
            snakeState.timer += dt;
            if (snakeState.timer < snakeState.speed) {
                drawSnake();
                return;
            }
            snakeState.timer = 0;

            snakeState.dir = snakeState.nextDir;
            const head = {
                x: snakeState.snake[0].x + snakeState.dir.x,
                y: snakeState.snake[0].y + snakeState.dir.y
            };

            // Walls
            const cols = canvas.width / snakeState.grid;
            const rows = canvas.height / snakeState.grid;

            if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows ||
                snakeState.snake.some(s => s.x === head.x && s.y === head.y)) {
                gameOver(snakeState.score);
                return;
            }

            snakeState.snake.unshift(head);
            sound.play('move');

            if (head.x === snakeState.food.x && head.y === snakeState.food.y) {
                snakeState.score += 10;
                sound.play('pop');
                currentScoreEl.textContent = snakeState.score;
                spawnSnakeFood();
                snakeState.speed = Math.max(50, snakeState.speed * 0.98); // Speed up
            } else {
                snakeState.snake.pop();
            }

            drawSnake();
        }

        function drawSnake() {
            const g = snakeState.grid;
            const f = snakeState.food;

            ctx.shadowBlur = 15;
            ctx.shadowColor = '#F59E0B';
            ctx.fillStyle = '#F59E0B';
            ctx.beginPath();
            ctx.arc(f.x * g + g/2, f.y * g + g/2, g/2 - 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 10;
            ctx.shadowColor = '#60A5FA';

            snakeState.snake.forEach((seg, i) => {
                ctx.fillStyle = i === 0 ? '#FFFFFF' : '#60A5FA';
                ctx.beginPath();
                ctx.arc(seg.x * g + g/2, seg.y * g + g/2, g/2 - 1, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        // --- TETRIS: CLUSTER BUILDER ---
        const tetrisShapes = [
            [[1,1,1,1]], // I
            [[1,1],[1,1]], // O
            [[0,1,0],[1,1,1]], // T
            [[1,0,0],[1,1,1]], // J
            [[0,0,1],[1,1,1]], // L
            [[0,1,1],[1,1,0]], // S
            [[1,1,0],[0,1,1]]  // Z
        ];
        const tetrisColors = ['#06B6D4', '#F59E0B', '#8B5CF6', '#3B82F6', '#F97316', '#10B981', '#EF4444'];

        function initTetris() {
            document.getElementById('modal-title').textContent = "Cluster Builder";
            controlsHintEl.textContent = "Arrows to Move/Rotate. 'P' to Pause.";
            tetrisState = {
                grid: 20,
                cols: 10,
                rows: 20,
                board: Array(20).fill().map(() => Array(10).fill(0)),
                score: 0,
                timer: 0,
                speed: 1000,
                piece: null
            };

            canvas.width = tetrisState.cols * tetrisState.grid;
            canvas.height = tetrisState.rows * tetrisState.grid;

            spawnTetrisPiece();
            currentScoreEl.textContent = 0;
            gameActive = true;
            lastTime = performance.now();
            music.start('tetris');
            loop(lastTime);
        }

        function spawnTetrisPiece() {
            const id = Math.floor(Math.random() * tetrisShapes.length);
            tetrisState.piece = {
                shape: tetrisShapes[id],
                color: tetrisColors[id],
                x: 3,
                y: 0
            };
            if (checkTetrisCollide()) {
                gameOver(tetrisState.score);
            }
        }

        function checkTetrisCollide(offX = 0, offY = 0, shape = null) {
            const s = shape || tetrisState.piece.shape;
            const px = tetrisState.piece.x + offX;
            const py = tetrisState.piece.y + offY;

            for (let y = 0; y < s.length; y++) {
                for (let x = 0; x < s[y].length; x++) {
                    if (s[y][x]) {
                        const bx = px + x;
                        const by = py + y;
                        if (bx < 0 || bx >= tetrisState.cols || by >= tetrisState.rows) return true;
                        if (by >= 0 && tetrisState.board[by][bx]) return true;
                    }
                }
            }
            return false;
        }

        function rotateTetrisPiece() {
            const piece = tetrisState.piece;
            const newShape = piece.shape[0].map((_, i) => piece.shape.map(row => row[i]).reverse());
            if (!checkTetrisCollide(0, 0, newShape)) {
                piece.shape = newShape;
                sound.play('move');
            }
        }

        function handleTetrisInput(e) {
            if (e.key === 'ArrowLeft') {
                if (!checkTetrisCollide(-1, 0)) { tetrisState.piece.x--; sound.play('move'); }
            }
            if (e.key === 'ArrowRight') {
                if (!checkTetrisCollide(1, 0)) { tetrisState.piece.x++; sound.play('move'); }
            }
            if (e.key === 'ArrowDown') {
                 if (!checkTetrisCollide(0, 1)) { tetrisState.piece.y++; }
            }
            if (e.key === 'ArrowUp') {
                rotateTetrisPiece();
            }
        }

        function updateTetris(dt) {
            tetrisState.timer += dt;
            if (tetrisState.timer > tetrisState.speed) {
                tetrisState.timer = 0;
                if (!checkTetrisCollide(0, 1)) {
                    tetrisState.piece.y++;
                } else {
                    const p = tetrisState.piece;
                    p.shape.forEach((row, y) => {
                        row.forEach((val, x) => {
                            if (val) {
                                if (p.y + y >= 0) {
                                    tetrisState.board[p.y + y][p.x + x] = p.color;
                                }
                            }
                        });
                    });

                    let lines = 0;
                    for (let y = tetrisState.rows - 1; y >= 0; y--) {
                        if (tetrisState.board[y].every(c => c !== 0)) {
                            tetrisState.board.splice(y, 1);
                            tetrisState.board.unshift(Array(tetrisState.cols).fill(0));
                            lines++;
                            y++;
                        }
                    }
                    if (lines > 0) {
                        tetrisState.score += lines * 100;
                        currentScoreEl.textContent = tetrisState.score;
                        sound.play('score');
                        tetrisState.speed *= 0.95;
                    } else {
                        sound.play('pop');
                    }

                    spawnTetrisPiece();
                }
            }
            drawTetris();
        }

        function drawTetris() {
            const g = tetrisState.grid;

            ctx.strokeStyle = '#1F2937';
            ctx.lineWidth = 1;
            for(let x=0; x<=canvas.width; x+=g) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }

            tetrisState.board.forEach((row, y) => {
                row.forEach((color, x) => {
                    if (color) {
                        drawBubble(x, y, color);
                    }
                });
            });

            if (tetrisState.piece) {
                tetrisState.piece.shape.forEach((row, y) => {
                    row.forEach((val, x) => {
                        if (val) {
                            drawBubble(tetrisState.piece.x + x, tetrisState.piece.y + y, tetrisState.piece.color, true);
                        }
                    });
                });
            }
        }

        function drawBubble(gx, gy, color, active=false) {
            const g = tetrisState.grid; // Assuming grid is used for sizing
            const x = gx * g + g/2;
            const y = gy * g + g/2;
            const r = g/2 - 2;

            ctx.fillStyle = color;
            ctx.shadowBlur = active ? 10 : 0;
            ctx.shadowColor = color;

            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(x - r/3, y - r/3, r/4, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
        }

        // --- BREAKOUT: FIREWALL BREAKER ---
        function initBreakout() {
            document.getElementById('modal-title').textContent = "Firewall Breaker";
            controlsHintEl.textContent = "Left/Right to Deflect. 'P' to Pause.";

            // Grid 8x5
            const rows = 5;
            const cols = 8;
            const padding = 10;
            const brickWidth = (canvas.width - (cols + 1) * padding) / cols;
            const brickHeight = 20;

            const bricks = [];
            const colors = ['#EF4444', '#F97316', '#F59E0B', '#10B981', '#3B82F6'];

            for(let c=0; c<cols; c++) {
                for(let r=0; r<rows; r++) {
                    bricks.push({
                        x: (c * (brickWidth + padding)) + padding,
                        y: (r * (brickHeight + padding)) + padding + 30, // Offset from top
                        w: brickWidth,
                        h: brickHeight,
                        active: true,
                        color: colors[r]
                    });
                }
            }

            breakoutState = {
                paddle: { x: canvas.width/2 - 40, y: canvas.height - 30, w: 80, h: 10, dx: 0, speed: 7 },
                ball: { x: canvas.width/2, y: canvas.height - 40, r: 6, dx: 4 * (Math.random() > 0.5 ? 1 : -1), dy: -4 },
                bricks: bricks,
                score: 0
            };

            canvas.width = 400; // Force size
            canvas.height = 400;

            currentScoreEl.textContent = 0;
            gameActive = true;
            lastTime = performance.now();
            music.start('breakout');
            loop(lastTime);
        }

        function handleBreakoutInput(e) {
            if (e.type === 'keydown') {
                if (e.key === 'ArrowLeft') breakoutState.paddle.dx = -breakoutState.paddle.speed;
                if (e.key === 'ArrowRight') breakoutState.paddle.dx = breakoutState.paddle.speed;
            }
            if (e.type === 'keyup') {
                if (e.key === 'ArrowLeft' && breakoutState.paddle.dx < 0) breakoutState.paddle.dx = 0;
                if (e.key === 'ArrowRight' && breakoutState.paddle.dx > 0) breakoutState.paddle.dx = 0;
            }
        }
        // Need KeyUp for smooth movement in Breakout
        document.addEventListener('keyup', (e) => {
            if (!gameActive || isPaused || currentGame !== 'breakout') return;
            handleBreakoutInput(e);
        });

        function updateBreakout(dt) {
            const s = breakoutState;

            // Move Paddle
            s.paddle.x += s.paddle.dx;
            if (s.paddle.x < 0) s.paddle.x = 0;
            if (s.paddle.x + s.paddle.w > canvas.width) s.paddle.x = canvas.width - s.paddle.w;

            // Move Ball
            s.ball.x += s.ball.dx;
            s.ball.y += s.ball.dy;

            // Walls
            if (s.ball.x - s.ball.r < 0 || s.ball.x + s.ball.r > canvas.width) {
                s.ball.dx *= -1;
                sound.play('bounce');
            }
            if (s.ball.y - s.ball.r < 0) {
                s.ball.dy *= -1;
                sound.play('bounce');
            }
            if (s.ball.y + s.ball.r > canvas.height) {
                gameOver(s.score);
                return;
            }

            // Paddle Hit
            if (s.ball.y + s.ball.r > s.paddle.y &&
                s.ball.x > s.paddle.x && s.ball.x < s.paddle.x + s.paddle.w) {
                s.ball.dy = -Math.abs(s.ball.dy); // Force up
                // Add English
                const hitPoint = (s.ball.x - (s.paddle.x + s.paddle.w/2)) / (s.paddle.w/2);
                s.ball.dx = hitPoint * 6; // Max curve
                sound.play('bounce');
            }

            // Bricks
            let hit = false;
            s.bricks.forEach(b => {
                if (!b.active || hit) return;
                // Simple collision AABB (ball treated as box for simplicity or circle-rect)
                // Let's do circle-rect closest point
                const cx = Math.max(b.x, Math.min(s.ball.x, b.x + b.w));
                const cy = Math.max(b.y, Math.min(s.ball.y, b.y + b.h));
                const dx = s.ball.x - cx;
                const dy = s.ball.y - cy;
                const dist = (dx*dx + dy*dy);

                if (dist < (s.ball.r * s.ball.r)) {
                    b.active = false;
                    s.score += 10;
                    currentScoreEl.textContent = s.score;
                    sound.play('pop');
                    hit = true;

                    // Reflect
                    // Basic logic: if mostly vertical overlap, flip Y, else X
                    // Normalized diff
                    if (Math.abs(dx) > Math.abs(dy)) s.ball.dx *= -1;
                    else s.ball.dy *= -1;
                }
            });

            // Level Clear
            if (s.bricks.every(b => !b.active)) {
                sound.play('score');
                // Reset Bricks
                s.bricks.forEach(b => b.active = true);
                s.ball.x = canvas.width/2;
                s.ball.y = canvas.height/2;
                s.ball.dy = Math.abs(s.ball.dy) + 1; // Speed up
            }

            drawBreakout();
        }

        function drawBreakout() {
            const s = breakoutState;

            // Paddle
            ctx.fillStyle = '#60A5FA';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#60A5FA';
            ctx.fillRect(s.paddle.x, s.paddle.y, s.paddle.w, s.paddle.h);

            // Ball
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(s.ball.x, s.ball.y, s.ball.r, 0, Math.PI*2);
            ctx.fill();

            // Bricks (Bubbles)
            s.bricks.forEach(b => {
                if (!b.active) return;
                // Draw as bubbles centered in the rect
                const cx = b.x + b.w/2;
                const cy = b.y + b.h/2;
                const r = Math.min(b.w, b.h)/2;

                ctx.fillStyle = b.color;
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI*2);
                ctx.fill();

                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(cx - r/3, cy - r/3, r/4, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        // --- TIC-TAC-TOE: NEURAL NODES ---
        function initTicTacToe() {
            document.getElementById('modal-title').textContent = "Neural Nodes";
            controlsHintEl.textContent = "Click a Node to Capture";
            tttState = {
                board: Array(9).fill(null),
                player: 'X',
                streak: 0,
                winner: null
            };
            gameActive = true;
            currentScoreEl.textContent = 0;
            drawTicTacToe();
        }

        function handleTicTacToeClick(e) {
            if (tttState.winner || tttState.player !== 'X') return;

            // Correctly calculate position relative to canvas internal size
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Grid is 3x3
            const cellW = canvas.width / 3;
            const cellH = canvas.height / 3;

            const col = Math.floor(x / cellW);
            const row = Math.floor(y / cellH);
            const idx = row * 3 + col;

            // Boundary check
            if (col < 0 || col > 2 || row < 0 || row > 2) return;

            if (tttState.board[idx] === null) {
                tttState.board[idx] = 'X';
                sound.play('pop');
                checkTTTWin();
                if (!tttState.winner) {
                    tttState.player = 'O';
                    drawTicTacToe();
                    setTimeout(cpuMove, 500);
                }
            }
            drawTicTacToe();
        }

        function cpuMove() {
            if (tttState.winner || !gameActive) return;
            const empty = tttState.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
            if (empty.length > 0) {
                const pick = empty[Math.floor(Math.random() * empty.length)];
                tttState.board[pick] = 'O';
                sound.play('move');
                checkTTTWin();
                if (!tttState.winner) {
                    tttState.player = 'X';
                }
                drawTicTacToe();
            }
        }

        function checkTTTWin() {
            const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            for (let w of wins) {
                const [a,b,c] = w;
                if (tttState.board[a] && tttState.board[a] === tttState.board[b] && tttState.board[a] === tttState.board[c]) {
                    tttState.winner = tttState.board[a];
                    endTTT(tttState.winner);
                    return;
                }
            }
            if (!tttState.board.includes(null)) {
                tttState.winner = 'draw';
                endTTT('draw');
            }
        }

        function endTTT(winner) {
            if (winner === 'X') {
                tttState.streak++;
                currentScoreEl.textContent = tttState.streak;
                sound.play('score');
                setTimeout(() => {
                    tttState.board.fill(null);
                    tttState.winner = null;
                    tttState.player = 'X'; // Player keeps turn
                    drawTicTacToe();
                }, 1000); // Auto restart for streak
            } else {
                gameActive = false;
                gameOver(tttState.streak); // Save streak
            }
        }

        function drawTicTacToe() {
            const w = canvas.width / 3;
            const h = canvas.height / 3;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Grid Lines
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(w, 0); ctx.lineTo(w, canvas.height);
            ctx.moveTo(w*2, 0); ctx.lineTo(w*2, canvas.height);
            ctx.moveTo(0, h); ctx.lineTo(canvas.width, h);
            ctx.moveTo(0, h*2); ctx.lineTo(canvas.width, h*2);
            ctx.stroke();

            // Draw Nodes
            tttState.board.forEach((cell, i) => {
                if (!cell) return;
                const col = i % 3;
                const row = Math.floor(i / 3);
                const cx = col * w + w/2;
                const cy = row * h + h/2;

                ctx.shadowBlur = 20;

                if (cell === 'X') {
                    // Blue Node
                    ctx.fillStyle = '#3B82F6';
                    ctx.shadowColor = '#3B82F6';
                    ctx.beginPath();
                    ctx.arc(cx, cy, w/3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Red Node
                    ctx.fillStyle = '#EF4444';
                    ctx.shadowColor = '#EF4444';
                    ctx.beginPath();
                    ctx.arc(cx, cy, w/3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            });
        }
    });
</script>
